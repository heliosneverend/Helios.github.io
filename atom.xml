<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Heliso</title>
  
  <subtitle>记录平时学习到的东西</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-03T07:43:10.384Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zyf</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>黑魔法Clang Attribute</title>
    <link href="http://yoursite.com/2018/09/03/%E9%BB%91%E9%AD%94%E6%B3%95Clang%20Attribute/"/>
    <id>http://yoursite.com/2018/09/03/黑魔法Clang Attribute/</id>
    <published>2018-09-03T03:07:16.000Z</published>
    <updated>2018-09-03T07:43:10.384Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Clang-Attribute-说明"><a href="#Clang-Attribute-说明" class="headerlink" title="Clang Attribute 说明"></a>Clang Attribute 说明</h1><p>Clang Attribute 是Clang提供的一种源码注解,一般以<strong>attribute</strong>(xxx) 的形式出现在代码中</p><h1 id="constructor-destructor"><a href="#constructor-destructor" class="headerlink" title="constructor / destructor"></a>constructor / destructor</h1><p>构造器和析构器，加上这两个属性的函数会在分别在可执行文件（或 shared library）load 和 unload 时被调用，可以理解为在 main() 函数调用前和 return 后执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((constructor))</span><br><span class="line">static void beforeMain(void) &#123;</span><br><span class="line">NSLog(@&quot;beforeMain&quot;);</span><br><span class="line">&#125;</span><br><span class="line">__attribute__((destructor))</span><br><span class="line">static void afterMain(void) &#123;</span><br><span class="line">NSLog(@&quot;afterMain&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">NSLog(@&quot;main&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Console:</span><br><span class="line">// &quot;beforeMain&quot; -&gt; &quot;main&quot; -&gt; &quot;afterMain&quot;</span><br></pre></td></tr></table></figure></p><p>constructor 和 +load 都是在 main 函数执行前调用，但 +load 比 constructor 更加早一丢丢，因为 dyld（动态链接器，程序的最初起点）在加载 image（可以理解成 Mach-O 文件）时会先通知 objc runtime 去加载其中所有的类，每加载一个类时，它的 +load 随之调用，全部加载完成后，dyld 才会调用这个 image 中所有的 constructor 方法。<br>所以 constructor 是一个干坏事的绝佳时机：<br>所有 Class 都已经加载完成<br>main 函数还未执行<br>无需像 +load 还得挂载在一个 Class 中<br>FDStackView 的 FDStackViewPatchEntry 方法便是使用的这个时机来实现偷天换日的伎俩。<br>PS：若有多个 constructor 且想控制优先级的话，可以写成 <strong>attribute</strong>((constructor(101)))，里面的数字越小优先级越高，1 ~ 100 为系统保留。</p><h1 id="enable-if"><a href="#enable-if" class="headerlink" title="enable_if"></a>enable_if</h1><p>这个属性只能用在 C 函数上，可以用来实现参数的静态检查：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static void printValidAge(int age)</span><br><span class="line">__attribute__((enable_if(age &gt; 0 &amp;&amp; age &lt; 120, &quot;你火星人？&quot;))) &#123;</span><br><span class="line">printf(&quot;%d&quot;, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它表示调用这个函数时必须满足 age &gt; 0 &amp;&amp; age &lt; 120 才被允许，于是乎：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">printValidAge(26); // √</span><br><span class="line">printValidAge(150); // &lt;--- Compile Error</span><br><span class="line">printValidAge(-1); // &lt;--- Compile Error</span><br></pre></td></tr></table></figure></p><h1 id="cleanup"><a href="#cleanup" class="headerlink" title="cleanup"></a>cleanup</h1><p>声明到一个变量上，当这个变量作用域结束时，调用指定的一个函数，Reactive Cocoa 用这个特性实现了神奇的 @onExit</p><h1 id="overloadable"><a href="#overloadable" class="headerlink" title="overloadable"></a>overloadable</h1><p>用于 C 函数，可以定义若干个函数名相同，但参数不同的方法，调用时编译器会自动根据参数选择函数原型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((overloadable)) void logAnything(id obj) &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, obj);</span><br><span class="line">&#125;</span><br><span class="line">__attribute__((overloadable)) void logAnything(int number) &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, @(number));</span><br><span class="line">&#125;</span><br><span class="line">__attribute__((overloadable)) void logAnything(CGRect rect) &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, NSStringFromCGRect(rect));</span><br><span class="line">&#125;</span><br><span class="line">// Tests</span><br><span class="line">logAnything(@[@&quot;1&quot;, @&quot;2&quot;]);</span><br><span class="line">logAnything(233);</span><br><span class="line">logAnything(CGRectMake(1, 2, 3, 4));</span><br></pre></td></tr></table></figure></p><h1 id="objc-subclassing-restricted"><a href="#objc-subclassing-restricted" class="headerlink" title="objc_subclassing_restricted"></a>objc_subclassing_restricted</h1><p>使用这个属性可以定义一个不可被继承的类,只需在@interface前面加上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((objc_subclassing_restricted))即可</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">__attribute__((objc_subclassing_restricted))</span><br><span class="line">@interface Person : NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@interface Child: Person //Cannot subclass a class that was declared with the &apos;objc_subclassing_restricted&apos; attribute</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h1 id="objc-requires-super"><a href="#objc-requires-super" class="headerlink" title="objc_requires_super"></a>objc_requires_super</h1><p>NS_REQUIRES_SUPER 子类继承该方法时需要调用 super 否则给出编译警告<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">- (void)fatherMethod __attribute__((objc_requires_super));</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Child</span><br><span class="line">- (void)fatherMethod &#123;</span><br><span class="line"> //Method possibly missing a [super fatherMethod] call</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h1 id="objc-runtime-name"><a href="#objc-runtime-name" class="headerlink" title="objc_runtime_name"></a>objc_runtime_name</h1><p>用于 @interface 或 @protocol，将类或协议的名字在编译时指定成另一个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((objc_runtime_name(&quot;SarkGay&quot;)))</span><br><span class="line">@interface Sark : NSObject</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;, NSStringFromClass([Sark class])); // &quot;SarkGay&quot;</span><br></pre></td></tr></table></figure></p><p>所有直接使用这个类名的地方都会被替换（唯一要注意的是这时用反射就不对了），最简单粗暴的用处就是去做个类名混淆：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((objc_runtime_name(&quot;40ea43d7629d01e4b8d6289a132482d0dd5df4fa&quot;)))</span><br><span class="line">@interface SecretClass : NSObject</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>还能用数字开头，怕不怕 - -，假如写个脚本把每个类前加个随机生成的 objc_runtime_name，岂不是最最精简版的代码混淆就完成了呢…</p><p>它是我所了解的唯一一个对 objc 运行时类结构有影响的 attribute，通过编码类名可以在编译时注入一些信息，被带到运行时之后，再反解出来，这就相当于开设了一条秘密通道，打通了写码时和运行时。脑洞一下，假如把这个 attribute 定义成宏，以 annotation 的形式完成某些功能，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// @singleton 包裹了 __attribute__((objc_runtime_name(...)))</span><br><span class="line">// 将类名改名成 &quot;SINGLETON_Sark_sharedInstance&quot;</span><br><span class="line">@singleton(Sark, sharedInstance)</span><br><span class="line">@interface Sark : NSObject</span><br><span class="line">+ (instancetype)sharedInstance;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>在运行时用 <strong>attribute</strong>((constructor)) 获取入口时机，用 runtime 找到这个类，反解出 “sharedInstance” 这个 selector 信息，动态将 + alloc，- init 等方法替换，返回 + sharedInstance 单例。</p><h1 id="objc-boxable"><a href="#objc-boxable" class="headerlink" title="objc_boxable"></a>objc_boxable</h1><p>Objective-C 中的 @(…) 语法糖可以将基本数据类型 box 成 NSNumber 对象，假如想 box 一个 struct 类型或是 union 类型成 NSValue 对象，可以使用这个属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef struct __attribute__((objc_boxable)) &#123;</span><br><span class="line">CGFloat x, y, width, height;</span><br><span class="line">&#125; XXRect;</span><br></pre></td></tr></table></figure></p><p>这样一来，XXRect 就具备被 box 的能力：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CGRect rect1 = &#123;1, 2, 3, 4&#125;;</span><br><span class="line">NSValue *value1 = @(rect1); // &lt;--- Compile Error</span><br><span class="line">XXRect rect2 = &#123;1, 2, 3, 4&#125;;</span><br><span class="line">NSValue *value2 = @(rect2); // √</span><br></pre></td></tr></table></figure></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://blog.sunnyxx.com/2016/05/14/clang-attributes/" target="_blank" rel="noopener">参考地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Clang-Attribute-说明&quot;&gt;&lt;a href=&quot;#Clang-Attribute-说明&quot; class=&quot;headerlink&quot; title=&quot;Clang Attribute 说明&quot;&gt;&lt;/a&gt;Clang Attribute 说明&lt;/h1&gt;&lt;p&gt;Clang 
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>React入门</title>
    <link href="http://yoursite.com/2018/09/03/React%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2018/09/03/React入门/</id>
    <published>2018-09-03T02:50:42.000Z</published>
    <updated>2018-09-03T07:47:00.290Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>swift和OC返回指定页面</title>
    <link href="http://yoursite.com/2018/08/27/swift%E5%92%8COC%E8%BF%94%E5%9B%9E%E6%8C%87%E5%AE%9A%E9%A1%B5%E9%9D%A2/"/>
    <id>http://yoursite.com/2018/08/27/swift和OC返回指定页面/</id>
    <published>2018-08-27T08:09:05.000Z</published>
    <updated>2018-09-03T07:46:40.455Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VC-多层-push后回到指定页面的几种方法"><a href="#VC-多层-push后回到指定页面的几种方法" class="headerlink" title="VC 多层 push后回到指定页面的几种方法"></a>VC 多层 push后回到指定页面的几种方法</h1><p>写一个ViewController的类方法,核心方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func backToViewController(className: String, animated: Bool) &#123;  </span><br><span class="line">        if ((self.navigationController) != nil) &#123;  </span><br><span class="line">            let controllers: Array = (self.navigationController?.viewControllers) ?? []  </span><br><span class="line">            let res = controllers.filter &#123; (item) -&gt; Bool in  </span><br><span class="line">                guard let aClass = NSClassFromString(className) else &#123;  </span><br><span class="line">                return false  </span><br><span class="line">            &#125;  </span><br><span class="line">            return item.isKind(of: aClass)  </span><br><span class="line">        &#125;  </span><br><span class="line">        if (res.count &gt; 0) &#123;  </span><br><span class="line">            self.navigationController?.popToViewController(res[0], animated: animated)  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/heliosneverend/popToViewController.git" target="_blank" rel="noopener">示例代码Demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;VC-多层-push后回到指定页面的几种方法&quot;&gt;&lt;a href=&quot;#VC-多层-push后回到指定页面的几种方法&quot; class=&quot;headerlink&quot; title=&quot;VC 多层 push后回到指定页面的几种方法&quot;&gt;&lt;/a&gt;VC 多层 push后回到指定页面的几种
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>记录苹果设备唯一账号</title>
    <link href="http://yoursite.com/2018/08/27/%E8%AE%B0%E5%BD%95%E8%8B%B9%E6%9E%9C%E8%AE%BE%E5%A4%87%E5%94%AF%E4%B8%80%E8%B4%A6%E5%8F%B7/"/>
    <id>http://yoursite.com/2018/08/27/记录苹果设备唯一账号/</id>
    <published>2018-08-27T03:28:21.000Z</published>
    <updated>2018-09-03T07:47:22.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS获取设备唯一标识符"><a href="#iOS获取设备唯一标识符" class="headerlink" title="iOS获取设备唯一标识符"></a>iOS获取设备唯一标识符</h1><h2 id="UDID-Unique-Device-Identifier"><a href="#UDID-Unique-Device-Identifier" class="headerlink" title="UDID(Unique Device Identifier)"></a>UDID(Unique Device Identifier)</h2><p>苹果IOS设备的唯一识别码, 越狱的设备通过某些工具可以改变设备的UDID,在iOS5.0(2011年8月份)开始，苹果宣布将不再支持uniqueIdentifier方法获取设备的UDID，iOS5以下是可以用的, 在 2013年3月21日苹果已经通知开发者,从2013年5月1日起，访问UIDIDs的程序将不再被审核通过替代的方案是开发者应该使用“在iOS 6中介绍的Vendor或Advertising标示符</p><hr><h2 id="UUID-Universally-Unique-Identifier"><a href="#UUID-Universally-Unique-Identifier" class="headerlink" title="UUID(Universally Unique Identifier)"></a>UUID(Universally Unique Identifier)</h2><p>唯一识别码<em>它是让分布式系统中的所有元素</em>都能有唯一的辨识资讯<em>而不需要透过中央控制端来做辨识资讯的指定</em>苹果公司建议使用UUID为应用生成唯一标识字符串](/uploads/a16006ef33534d3c6a28263d112ebed7/唯一识别码<em>它是让分布式系统中的所有元素</em>都能有唯一的辨识资讯<em>而不需要透过中央控制端来做辨识资讯的指定</em>苹果公司建议使用UUID为应用生成唯一标识字符串</p><hr><h2 id="MAC-Address-Medium-Access-Control"><a href="#MAC-Address-Medium-Access-Control" class="headerlink" title="MAC Address(Medium Access Control)"></a>MAC Address(Medium Access Control)</h2><p>媒体访问控制，或称为物理地址、硬件地址，用来定义网络设备的位置。在OSI模型中，第三层网络层负责 IP地址，第二层数据链路层则负责 MAC地址。因此一个主机会有一个MAC地址，而每个网络位置会有一个专属于它的IP地址。MAC地址是网卡决定的，是固定的</p><hr><h2 id="OPEN-UDID"><a href="#OPEN-UDID" class="headerlink" title="OPEN UDID"></a>OPEN UDID</h2><p>OpenUDID是通过第一个带有OpenUDID SDK包的App生成，如果你完全删除全部带有OpenUDID SDK包的App（比如恢复系统等），那么OpenUDID会重新生成，而且和之前的值会不同，相当于新设备； 优点是没有用到MAC地址；不同设备能够获取各自唯一的识别码，保证了唯一性，可以用于以往UDID的相关用途；从代码分析OpenUDID的获取，识别码获取方便并且保存谨慎。缺点是当将设备上所有使用了OpenUDID方案的应用程序删除，且设备关机重启，xcode彻底清除并重启，重装应用程序去获取OpenUDID，此时OpenUDID变化，与之前不一样了，所有OpenUDID应用卸载后，由UIPasteboard保存的数据即被清除，重装故会重新获取新的OpenUDID。 那么当因为用户干预或者恶意程序，致使UIPasteboard数据清除，从而导致OpenUDID被删除，重装也会获取新的OpenUDID。</p><hr><h2 id="广告标识符-IDFA-identifierForldentifier"><a href="#广告标识符-IDFA-identifierForldentifier" class="headerlink" title="广告标识符(IDFA-identifierForldentifier)"></a>广告标识符(IDFA-identifierForldentifier)</h2><p>是iOS 6中另外一个新的方法，提供了一个方法advertisingIdentifier，通过调用该方法会返回一个NSUUID实例，最后可以获得一个UUID，由系统存储着的。不过即使这是由系统存储的，但是有几种情况下，会重新生成广告标示符。如果用户完全重置系统（(设置程序 -&gt; 通用 -&gt; 还原 -&gt; 还原位置与隐私) ，这个广告标示符会重新生成。另外如果用户明确的还原广告(设置程序-&gt; 通用 -&gt; 关于本机 -&gt; 广告 -&gt; 还原广告标示符) ，那么广告标示符也会重新生成。关于广告标示符的还原，有一点需要注意：如果程序在后台运行，此时用户“还原广告标示符”，然后再回到程序中，此时获取广 告标示符并不会立即获得还原后的标示符。必须要终止程序，然后再重新启动程序，才能获得还原后的广告标示符。</p><hr><h2 id="Vendor标识符-IDFV-identifierForVendor"><a href="#Vendor标识符-IDFV-identifierForVendor" class="headerlink" title="Vendor标识符(IDFV-identifierForVendor)"></a>Vendor标识符(IDFV-identifierForVendor)</h2><p>Vendor是CFBundleIdentifier（反转DNS格式）的前两部分。来自同一个运营商的应用运行在同一个设备上，此属性的值是相同的；不同的运营商应用运行在同一个设备上值不同。 经测试，只要设备上有一个运营商的app，重新安装后的identifierForVendor值不变，如果该运营商的app全部删除，重新安装后的identifierForVendor值改变。</p><hr><h2 id="调研结果"><a href="#调研结果" class="headerlink" title="调研结果"></a>调研结果</h2><p>IMEI 苹果允许的API 但不能获取,不会变化,设备唯一。</p><hr><p>UDID 曾经可以获取,单现在也成为禁止调用的API,不会变化,设备唯一。</p><hr><p>MAC 不能直接通过设备API获取,某种脑洞可以通过WIFI下路由器反馈信息来回传MAC地址,很不方便不会变化,设备唯一</p><hr><p>IDFA 广告标示符,经常容易变,每当用户针对应用程序关闭再开启一次广告追踪就会发生变化</p><hr><p>IDFV 厂商标示符,不太容易变,每当用户卸载完应用厂家旗下所有的应用程序后,再次安装,会发生变化</p><hr><p>NSUUID 苹果API接口,每次获取都变化</p><hr><p>可以确认的是，在众多可选的标识方案里，都不能保证永远不变，所以必须配合钥匙扣使用，有了钥匙扣至少保证，只要用户不刷机，无论是升级系统，还是卸载光所有的应用程序，都不会发生变化,只要有了钥匙扣的辅助，可以说随便选一个标识，只要存入钥匙圈，都能保证不变了。推荐选择了目前来看更加稳定的IDFV</p><p><a href="https://github.com/heliosneverend/HeliosKeychain" target="_blank" rel="noopener">示例代码Demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;iOS获取设备唯一标识符&quot;&gt;&lt;a href=&quot;#iOS获取设备唯一标识符&quot; class=&quot;headerlink&quot; title=&quot;iOS获取设备唯一标识符&quot;&gt;&lt;/a&gt;iOS获取设备唯一标识符&lt;/h1&gt;&lt;h2 id=&quot;UDID-Unique-Device-Identi
      
    
    </summary>
    
      <category term="拾遗" scheme="http://yoursite.com/categories/%E6%8B%BE%E9%81%97/"/>
    
    
      <category term="拾遗" scheme="http://yoursite.com/tags/%E6%8B%BE%E9%81%97/"/>
    
  </entry>
  
  <entry>
    <title>赫夫曼树和赫夫曼编码</title>
    <link href="http://yoursite.com/2017/01/02/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%92%8C%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/"/>
    <id>http://yoursite.com/2017/01/02/赫夫曼树和赫夫曼编码/</id>
    <published>2017-01-02T02:26:59.000Z</published>
    <updated>2018-09-03T08:48:45.493Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="http://yoursite.com/2017/01/01/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2017/01/01/二叉树/</id>
    <published>2017-01-01T12:03:59.000Z</published>
    <updated>2018-09-03T08:47:56.303Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>树及存储结构</title>
    <link href="http://yoursite.com/2016/12/03/%E6%A0%91%E5%8F%8A%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2016/12/03/树及存储结构/</id>
    <published>2016-12-03T08:03:46.000Z</published>
    <updated>2018-09-03T08:46:58.463Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>字符串匹配的BF算法和KMP算法</title>
    <link href="http://yoursite.com/2016/10/12/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%9A%84BF%E7%AE%97%E6%B3%95%E5%92%8CKMP%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2016/10/12/字符串匹配的BF算法和KMP算法/</id>
    <published>2016-10-12T07:19:22.000Z</published>
    <updated>2018-09-03T08:45:39.244Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>栈和队列</title>
    <link href="http://yoursite.com/2016/09/03/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2016/09/03/栈和队列/</id>
    <published>2016-09-03T00:29:31.000Z</published>
    <updated>2018-09-03T08:44:22.858Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>双向链表</title>
    <link href="http://yoursite.com/2016/08/16/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2016/08/16/双向链表/</id>
    <published>2016-08-16T10:29:31.000Z</published>
    <updated>2018-09-03T08:46:14.075Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>线性表</title>
    <link href="http://yoursite.com/2016/07/16/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>http://yoursite.com/2016/07/16/线性表/</id>
    <published>2016-07-16T00:19:31.000Z</published>
    <updated>2018-09-03T08:42:41.723Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线性表定义："><a href="#线性表定义：" class="headerlink" title="线性表定义："></a>线性表定义：</h2><p>作为常见的一种数据结构，线性表是由0个或者多个数据元素组成的有限序列。<br><img src="/images/header.jepg" alt="线性表"><br>a1无前驱元素，a1是a2的前驱元素，a2是a1的后继元素，an无后继元素；<br>当n=0时候，称为空表。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;线性表定义：&quot;&gt;&lt;a href=&quot;#线性表定义：&quot; class=&quot;headerlink&quot; title=&quot;线性表定义：&quot;&gt;&lt;/a&gt;线性表定义：&lt;/h2&gt;&lt;p&gt;作为常见的一种数据结构，线性表是由0个或者多个数据元素组成的有限序列。&lt;br&gt;&lt;img src=&quot;/imag
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>循环链表</title>
    <link href="http://yoursite.com/2016/07/04/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2016/07/04/循环链表/</id>
    <published>2016-07-04T04:09:25.000Z</published>
    <updated>2018-09-03T08:43:53.351Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>静态链表</title>
    <link href="http://yoursite.com/2016/07/03/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2016/07/03/静态链表/</id>
    <published>2016-07-03T05:09:25.000Z</published>
    <updated>2018-09-03T08:47:28.808Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>单向链表的整表操作</title>
    <link href="http://yoursite.com/2016/06/13/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E6%95%B4%E8%A1%A8%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2016/06/13/单向链表的整表操作/</id>
    <published>2016-06-13T11:11:25.000Z</published>
    <updated>2018-09-03T08:49:31.083Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>度量算法效率的方法</title>
    <link href="http://yoursite.com/2016/05/03/%E5%BA%A6%E9%87%8F%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/05/03/度量算法效率的方法/</id>
    <published>2016-05-03T01:10:25.000Z</published>
    <updated>2018-09-03T08:07:18.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。</p><p>算法的时间复杂度，也就是算法的时间量度，记做T(n)=O(f(n))。<br>他表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。其中，f(n)是问题的规模n的某个函数。</p><p>这样用大写字母O来体现算法时间复杂度的记法，常称之为大O记法。</p><h2 id="如何推导时间复杂度："><a href="#如何推导时间复杂度：" class="headerlink" title="如何推导时间复杂度："></a>如何推导时间复杂度：</h2><p>用常数1来取代运行时间中所有加法常数，如：1+2+3 = 1,记为O(1)<br>在修改后的运行次数函数中，只保留最高阶项，如：n+n^2 = n^2,记为O(n^2)<br>如果最高阶项存在且不是1，则去除与这个项相乘的常数，如：3n^2 = n^2,记为O(n^2)</p><h2 id="计算下面程序的时间复杂度"><a href="#计算下面程序的时间复杂度" class="headerlink" title="计算下面程序的时间复杂度"></a>计算下面程序的时间复杂度</h2><p>例题1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">int b = 0;</span><br><span class="line">int c = a + b;</span><br><span class="line">printf(&quot;hello world&quot;);</span><br><span class="line">答案 O(1)</span><br></pre></td></tr></table></figure></p><p>例题2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0 ; i &lt; 100; i++) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">答案 O(n)</span><br></pre></td></tr></table></figure></p><p>例题3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0 ; i &lt; 100; i++) &#123;</span><br><span class="line">    for (int j = 0 ; j &lt; 100; j++) &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">答案:O(n^2)</span><br></pre></td></tr></table></figure></p><p>例题4<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0 ; i &lt; 100; i++) &#123;</span><br><span class="line">    for (int j = i ; j &lt; i; j++) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//分析：执行次数 = n + (n-1) + (n-2) +...+1 = n * (n + 1) / 2 = (n^2) / 2 + n / 2</span><br><span class="line">答案: O(n^2)</span><br></pre></td></tr></table></figure></p><p>例题5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    int i = 1, n = 100;</span><br><span class="line">    while (i &lt; n) &#123;</span><br><span class="line">        i = i * 2;</span><br><span class="line">    &#125;</span><br><span class="line">//分析：退出条件是2*x = = n，可以得到x = log(2)n -- 以2为底，n的对数</span><br><span class="line">答案:O(logn)</span><br></pre></td></tr></table></figure></p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>算法的空间复杂度：通过计算算法所需的存储空间实现，算法的空间复杂度的计算公式记为：S(n) = O(f(n)),其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;时间复杂度&quot;&gt;&lt;a href=&quot;#时间复杂度&quot; class=&quot;headerlink&quot; title=&quot;时间复杂度&quot;&gt;&lt;/a&gt;时间复杂度&lt;/h1&gt;&lt;p&gt;在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
