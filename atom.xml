<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Heliso</title>
  
  <subtitle>记录平时学习到的东西</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-27T08:16:30.304Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zyf</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>swift和OC返回指定页面</title>
    <link href="http://yoursite.com/2018/08/27/swift%E5%92%8COC%E8%BF%94%E5%9B%9E%E6%8C%87%E5%AE%9A%E9%A1%B5%E9%9D%A2/"/>
    <id>http://yoursite.com/2018/08/27/swift和OC返回指定页面/</id>
    <published>2018-08-27T08:09:05.000Z</published>
    <updated>2018-08-27T08:16:30.304Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VC-多层-push后回到指定页面的几种方法"><a href="#VC-多层-push后回到指定页面的几种方法" class="headerlink" title="VC 多层 push后回到指定页面的几种方法"></a>VC 多层 push后回到指定页面的几种方法</h1><p>写一个ViewController的类方法,核心方法<br>func backToViewController(className: String, animated: Bool) {<br>        if ((self.navigationController) != nil) {<br>            let controllers: Array = (self.navigationController?.viewControllers) ?? []<br>            let res = controllers.filter { (item) -&gt; Bool in<br>            guard let aClass = NSClassFromString(className) else {<br>            return false<br>            }<br>            return item.isKind(of: aClass)<br>    }<br>        if (res.count &gt; 0) {<br>        self.navigationController?.popToViewController(res[0], animated: animated)<br>        }<br>    }<br>}<br><a href="https://github.com/heliosneverend/popToViewController.git" target="_blank" rel="noopener">示例代码Demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;VC-多层-push后回到指定页面的几种方法&quot;&gt;&lt;a href=&quot;#VC-多层-push后回到指定页面的几种方法&quot; class=&quot;headerlink&quot; title=&quot;VC 多层 push后回到指定页面的几种方法&quot;&gt;&lt;/a&gt;VC 多层 push后回到指定页面的几种
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>记录苹果设备唯一账号</title>
    <link href="http://yoursite.com/2018/08/27/%E8%AE%B0%E5%BD%95%E8%8B%B9%E6%9E%9C%E8%AE%BE%E5%A4%87%E5%94%AF%E4%B8%80%E8%B4%A6%E5%8F%B7/"/>
    <id>http://yoursite.com/2018/08/27/记录苹果设备唯一账号/</id>
    <published>2018-08-27T03:28:21.000Z</published>
    <updated>2018-08-27T03:31:15.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS获取设备唯一标识符"><a href="#iOS获取设备唯一标识符" class="headerlink" title="iOS获取设备唯一标识符"></a>iOS获取设备唯一标识符</h1><h2 id="UDID-Unique-Device-Identifier"><a href="#UDID-Unique-Device-Identifier" class="headerlink" title="UDID(Unique Device Identifier)"></a>UDID(Unique Device Identifier)</h2><p>苹果IOS设备的唯一识别码, 越狱的设备通过某些工具可以改变设备的UDID,在iOS5.0(2011年8月份)开始，苹果宣布将不再支持uniqueIdentifier方法获取设备的UDID，iOS5以下是可以用的, 在 2013年3月21日苹果已经通知开发者,从2013年5月1日起，访问UIDIDs的程序将不再被审核通过替代的方案是开发者应该使用“在iOS 6中介绍的Vendor或Advertising标示符</p><hr><h2 id="UUID-Universally-Unique-Identifier"><a href="#UUID-Universally-Unique-Identifier" class="headerlink" title="UUID(Universally Unique Identifier)"></a>UUID(Universally Unique Identifier)</h2><p>唯一识别码<em>它是让分布式系统中的所有元素</em>都能有唯一的辨识资讯<em>而不需要透过中央控制端来做辨识资讯的指定</em>苹果公司建议使用UUID为应用生成唯一标识字符串](/uploads/a16006ef33534d3c6a28263d112ebed7/唯一识别码<em>它是让分布式系统中的所有元素</em>都能有唯一的辨识资讯<em>而不需要透过中央控制端来做辨识资讯的指定</em>苹果公司建议使用UUID为应用生成唯一标识字符串</p><hr><h2 id="MAC-Address-Medium-Access-Control"><a href="#MAC-Address-Medium-Access-Control" class="headerlink" title="MAC Address(Medium Access Control)"></a>MAC Address(Medium Access Control)</h2><p>媒体访问控制，或称为物理地址、硬件地址，用来定义网络设备的位置。在OSI模型中，第三层网络层负责 IP地址，第二层数据链路层则负责 MAC地址。因此一个主机会有一个MAC地址，而每个网络位置会有一个专属于它的IP地址。MAC地址是网卡决定的，是固定的</p><hr><h2 id="OPEN-UDID"><a href="#OPEN-UDID" class="headerlink" title="OPEN UDID"></a>OPEN UDID</h2><p>OpenUDID是通过第一个带有OpenUDID SDK包的App生成，如果你完全删除全部带有OpenUDID SDK包的App（比如恢复系统等），那么OpenUDID会重新生成，而且和之前的值会不同，相当于新设备； 优点是没有用到MAC地址；不同设备能够获取各自唯一的识别码，保证了唯一性，可以用于以往UDID的相关用途；从代码分析OpenUDID的获取，识别码获取方便并且保存谨慎。缺点是当将设备上所有使用了OpenUDID方案的应用程序删除，且设备关机重启，xcode彻底清除并重启，重装应用程序去获取OpenUDID，此时OpenUDID变化，与之前不一样了，所有OpenUDID应用卸载后，由UIPasteboard保存的数据即被清除，重装故会重新获取新的OpenUDID。 那么当因为用户干预或者恶意程序，致使UIPasteboard数据清除，从而导致OpenUDID被删除，重装也会获取新的OpenUDID。</p><hr><h2 id="广告标识符-IDFA-identifierForldentifier"><a href="#广告标识符-IDFA-identifierForldentifier" class="headerlink" title="广告标识符(IDFA-identifierForldentifier)"></a>广告标识符(IDFA-identifierForldentifier)</h2><p>是iOS 6中另外一个新的方法，提供了一个方法advertisingIdentifier，通过调用该方法会返回一个NSUUID实例，最后可以获得一个UUID，由系统存储着的。不过即使这是由系统存储的，但是有几种情况下，会重新生成广告标示符。如果用户完全重置系统（(设置程序 -&gt; 通用 -&gt; 还原 -&gt; 还原位置与隐私) ，这个广告标示符会重新生成。另外如果用户明确的还原广告(设置程序-&gt; 通用 -&gt; 关于本机 -&gt; 广告 -&gt; 还原广告标示符) ，那么广告标示符也会重新生成。关于广告标示符的还原，有一点需要注意：如果程序在后台运行，此时用户“还原广告标示符”，然后再回到程序中，此时获取广 告标示符并不会立即获得还原后的标示符。必须要终止程序，然后再重新启动程序，才能获得还原后的广告标示符。</p><hr><h2 id="Vendor标识符-IDFV-identifierForVendor"><a href="#Vendor标识符-IDFV-identifierForVendor" class="headerlink" title="Vendor标识符(IDFV-identifierForVendor)"></a>Vendor标识符(IDFV-identifierForVendor)</h2><p>Vendor是CFBundleIdentifier（反转DNS格式）的前两部分。来自同一个运营商的应用运行在同一个设备上，此属性的值是相同的；不同的运营商应用运行在同一个设备上值不同。 经测试，只要设备上有一个运营商的app，重新安装后的identifierForVendor值不变，如果该运营商的app全部删除，重新安装后的identifierForVendor值改变。</p><hr><h2 id="调研结果"><a href="#调研结果" class="headerlink" title="调研结果"></a>调研结果</h2><p>IMEI 苹果允许的API 但不能获取,不会变化,设备唯一。</p><hr><p>UDID 曾经可以获取,单现在也成为禁止调用的API,不会变化,设备唯一。</p><hr><p>MAC 不能直接通过设备API获取,某种脑洞可以通过WIFI下路由器反馈信息来回传MAC地址,很不方便不会变化,设备唯一</p><hr><p>IDFA 广告标示符,经常容易变,每当用户针对应用程序关闭再开启一次广告追踪就会发生变化</p><hr><p>IDFV 厂商标示符,不太容易变,每当用户卸载完应用厂家旗下所有的应用程序后,再次安装,会发生变化</p><hr><p>NSUUID 苹果API接口,每次获取都变化</p><hr><p>可以确认的是，在众多可选的标识方案里，都不能保证永远不变，所以必须配合钥匙扣使用，有了钥匙扣至少保证，只要用户不刷机，无论是升级系统，还是卸载光所有的应用程序，都不会发生变化,只要有了钥匙扣的辅助，可以说随便选一个标识，只要存入钥匙圈，都能保证不变了。推荐选择了目前来看更加稳定的IDFV</p><p><a href="https://github.com/heliosneverend/HeliosKeychain" target="_blank" rel="noopener">示例代码Demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;iOS获取设备唯一标识符&quot;&gt;&lt;a href=&quot;#iOS获取设备唯一标识符&quot; class=&quot;headerlink&quot; title=&quot;iOS获取设备唯一标识符&quot;&gt;&lt;/a&gt;iOS获取设备唯一标识符&lt;/h1&gt;&lt;h2 id=&quot;UDID-Unique-Device-Identi
      
    
    </summary>
    
    
  </entry>
  
</feed>
