<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Heliso</title>
  
  <subtitle>记录平时学习到的东西</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-03T07:43:10.384Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zyf</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>黑魔法Clang Attribute</title>
    <link href="http://yoursite.com/2018/09/03/%E9%BB%91%E9%AD%94%E6%B3%95Clang%20Attribute/"/>
    <id>http://yoursite.com/2018/09/03/黑魔法Clang Attribute/</id>
    <published>2018-09-03T03:07:16.000Z</published>
    <updated>2018-09-03T07:43:10.384Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Clang-Attribute-说明"><a href="#Clang-Attribute-说明" class="headerlink" title="Clang Attribute 说明"></a>Clang Attribute 说明</h1><p>Clang Attribute 是Clang提供的一种源码注解,一般以<strong>attribute</strong>(xxx) 的形式出现在代码中</p><h1 id="constructor-destructor"><a href="#constructor-destructor" class="headerlink" title="constructor / destructor"></a>constructor / destructor</h1><p>构造器和析构器，加上这两个属性的函数会在分别在可执行文件（或 shared library）load 和 unload 时被调用，可以理解为在 main() 函数调用前和 return 后执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((constructor))</span><br><span class="line">static void beforeMain(void) &#123;</span><br><span class="line">NSLog(@&quot;beforeMain&quot;);</span><br><span class="line">&#125;</span><br><span class="line">__attribute__((destructor))</span><br><span class="line">static void afterMain(void) &#123;</span><br><span class="line">NSLog(@&quot;afterMain&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">NSLog(@&quot;main&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Console:</span><br><span class="line">// &quot;beforeMain&quot; -&gt; &quot;main&quot; -&gt; &quot;afterMain&quot;</span><br></pre></td></tr></table></figure></p><p>constructor 和 +load 都是在 main 函数执行前调用，但 +load 比 constructor 更加早一丢丢，因为 dyld（动态链接器，程序的最初起点）在加载 image（可以理解成 Mach-O 文件）时会先通知 objc runtime 去加载其中所有的类，每加载一个类时，它的 +load 随之调用，全部加载完成后，dyld 才会调用这个 image 中所有的 constructor 方法。<br>所以 constructor 是一个干坏事的绝佳时机：<br>所有 Class 都已经加载完成<br>main 函数还未执行<br>无需像 +load 还得挂载在一个 Class 中<br>FDStackView 的 FDStackViewPatchEntry 方法便是使用的这个时机来实现偷天换日的伎俩。<br>PS：若有多个 constructor 且想控制优先级的话，可以写成 <strong>attribute</strong>((constructor(101)))，里面的数字越小优先级越高，1 ~ 100 为系统保留。</p><h1 id="enable-if"><a href="#enable-if" class="headerlink" title="enable_if"></a>enable_if</h1><p>这个属性只能用在 C 函数上，可以用来实现参数的静态检查：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static void printValidAge(int age)</span><br><span class="line">__attribute__((enable_if(age &gt; 0 &amp;&amp; age &lt; 120, &quot;你火星人？&quot;))) &#123;</span><br><span class="line">printf(&quot;%d&quot;, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它表示调用这个函数时必须满足 age &gt; 0 &amp;&amp; age &lt; 120 才被允许，于是乎：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">printValidAge(26); // √</span><br><span class="line">printValidAge(150); // &lt;--- Compile Error</span><br><span class="line">printValidAge(-1); // &lt;--- Compile Error</span><br></pre></td></tr></table></figure></p><h1 id="cleanup"><a href="#cleanup" class="headerlink" title="cleanup"></a>cleanup</h1><p>声明到一个变量上，当这个变量作用域结束时，调用指定的一个函数，Reactive Cocoa 用这个特性实现了神奇的 @onExit</p><h1 id="overloadable"><a href="#overloadable" class="headerlink" title="overloadable"></a>overloadable</h1><p>用于 C 函数，可以定义若干个函数名相同，但参数不同的方法，调用时编译器会自动根据参数选择函数原型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((overloadable)) void logAnything(id obj) &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, obj);</span><br><span class="line">&#125;</span><br><span class="line">__attribute__((overloadable)) void logAnything(int number) &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, @(number));</span><br><span class="line">&#125;</span><br><span class="line">__attribute__((overloadable)) void logAnything(CGRect rect) &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, NSStringFromCGRect(rect));</span><br><span class="line">&#125;</span><br><span class="line">// Tests</span><br><span class="line">logAnything(@[@&quot;1&quot;, @&quot;2&quot;]);</span><br><span class="line">logAnything(233);</span><br><span class="line">logAnything(CGRectMake(1, 2, 3, 4));</span><br></pre></td></tr></table></figure></p><h1 id="objc-subclassing-restricted"><a href="#objc-subclassing-restricted" class="headerlink" title="objc_subclassing_restricted"></a>objc_subclassing_restricted</h1><p>使用这个属性可以定义一个不可被继承的类,只需在@interface前面加上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((objc_subclassing_restricted))即可</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">__attribute__((objc_subclassing_restricted))</span><br><span class="line">@interface Person : NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@interface Child: Person //Cannot subclass a class that was declared with the &apos;objc_subclassing_restricted&apos; attribute</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h1 id="objc-requires-super"><a href="#objc-requires-super" class="headerlink" title="objc_requires_super"></a>objc_requires_super</h1><p>NS_REQUIRES_SUPER 子类继承该方法时需要调用 super 否则给出编译警告<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">- (void)fatherMethod __attribute__((objc_requires_super));</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Child</span><br><span class="line">- (void)fatherMethod &#123;</span><br><span class="line"> //Method possibly missing a [super fatherMethod] call</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h1 id="objc-runtime-name"><a href="#objc-runtime-name" class="headerlink" title="objc_runtime_name"></a>objc_runtime_name</h1><p>用于 @interface 或 @protocol，将类或协议的名字在编译时指定成另一个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((objc_runtime_name(&quot;SarkGay&quot;)))</span><br><span class="line">@interface Sark : NSObject</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;, NSStringFromClass([Sark class])); // &quot;SarkGay&quot;</span><br></pre></td></tr></table></figure></p><p>所有直接使用这个类名的地方都会被替换（唯一要注意的是这时用反射就不对了），最简单粗暴的用处就是去做个类名混淆：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((objc_runtime_name(&quot;40ea43d7629d01e4b8d6289a132482d0dd5df4fa&quot;)))</span><br><span class="line">@interface SecretClass : NSObject</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>还能用数字开头，怕不怕 - -，假如写个脚本把每个类前加个随机生成的 objc_runtime_name，岂不是最最精简版的代码混淆就完成了呢…</p><p>它是我所了解的唯一一个对 objc 运行时类结构有影响的 attribute，通过编码类名可以在编译时注入一些信息，被带到运行时之后，再反解出来，这就相当于开设了一条秘密通道，打通了写码时和运行时。脑洞一下，假如把这个 attribute 定义成宏，以 annotation 的形式完成某些功能，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// @singleton 包裹了 __attribute__((objc_runtime_name(...)))</span><br><span class="line">// 将类名改名成 &quot;SINGLETON_Sark_sharedInstance&quot;</span><br><span class="line">@singleton(Sark, sharedInstance)</span><br><span class="line">@interface Sark : NSObject</span><br><span class="line">+ (instancetype)sharedInstance;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>在运行时用 <strong>attribute</strong>((constructor)) 获取入口时机，用 runtime 找到这个类，反解出 “sharedInstance” 这个 selector 信息，动态将 + alloc，- init 等方法替换，返回 + sharedInstance 单例。</p><h1 id="objc-boxable"><a href="#objc-boxable" class="headerlink" title="objc_boxable"></a>objc_boxable</h1><p>Objective-C 中的 @(…) 语法糖可以将基本数据类型 box 成 NSNumber 对象，假如想 box 一个 struct 类型或是 union 类型成 NSValue 对象，可以使用这个属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef struct __attribute__((objc_boxable)) &#123;</span><br><span class="line">CGFloat x, y, width, height;</span><br><span class="line">&#125; XXRect;</span><br></pre></td></tr></table></figure></p><p>这样一来，XXRect 就具备被 box 的能力：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CGRect rect1 = &#123;1, 2, 3, 4&#125;;</span><br><span class="line">NSValue *value1 = @(rect1); // &lt;--- Compile Error</span><br><span class="line">XXRect rect2 = &#123;1, 2, 3, 4&#125;;</span><br><span class="line">NSValue *value2 = @(rect2); // √</span><br></pre></td></tr></table></figure></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://blog.sunnyxx.com/2016/05/14/clang-attributes/" target="_blank" rel="noopener">参考地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Clang-Attribute-说明&quot;&gt;&lt;a href=&quot;#Clang-Attribute-说明&quot; class=&quot;headerlink&quot; title=&quot;Clang Attribute 说明&quot;&gt;&lt;/a&gt;Clang Attribute 说明&lt;/h1&gt;&lt;p&gt;Clang 
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>React入门</title>
    <link href="http://yoursite.com/2018/09/03/React%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2018/09/03/React入门/</id>
    <published>2018-09-03T02:50:42.000Z</published>
    <updated>2018-09-03T07:47:00.290Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>swift和OC返回指定页面</title>
    <link href="http://yoursite.com/2018/08/27/swift%E5%92%8COC%E8%BF%94%E5%9B%9E%E6%8C%87%E5%AE%9A%E9%A1%B5%E9%9D%A2/"/>
    <id>http://yoursite.com/2018/08/27/swift和OC返回指定页面/</id>
    <published>2018-08-27T08:09:05.000Z</published>
    <updated>2018-09-03T07:46:40.455Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VC-多层-push后回到指定页面的几种方法"><a href="#VC-多层-push后回到指定页面的几种方法" class="headerlink" title="VC 多层 push后回到指定页面的几种方法"></a>VC 多层 push后回到指定页面的几种方法</h1><p>写一个ViewController的类方法,核心方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func backToViewController(className: String, animated: Bool) &#123;  </span><br><span class="line">        if ((self.navigationController) != nil) &#123;  </span><br><span class="line">            let controllers: Array = (self.navigationController?.viewControllers) ?? []  </span><br><span class="line">            let res = controllers.filter &#123; (item) -&gt; Bool in  </span><br><span class="line">                guard let aClass = NSClassFromString(className) else &#123;  </span><br><span class="line">                return false  </span><br><span class="line">            &#125;  </span><br><span class="line">            return item.isKind(of: aClass)  </span><br><span class="line">        &#125;  </span><br><span class="line">        if (res.count &gt; 0) &#123;  </span><br><span class="line">            self.navigationController?.popToViewController(res[0], animated: animated)  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/heliosneverend/popToViewController.git" target="_blank" rel="noopener">示例代码Demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;VC-多层-push后回到指定页面的几种方法&quot;&gt;&lt;a href=&quot;#VC-多层-push后回到指定页面的几种方法&quot; class=&quot;headerlink&quot; title=&quot;VC 多层 push后回到指定页面的几种方法&quot;&gt;&lt;/a&gt;VC 多层 push后回到指定页面的几种
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>记录苹果设备唯一账号</title>
    <link href="http://yoursite.com/2018/08/27/%E8%AE%B0%E5%BD%95%E8%8B%B9%E6%9E%9C%E8%AE%BE%E5%A4%87%E5%94%AF%E4%B8%80%E8%B4%A6%E5%8F%B7/"/>
    <id>http://yoursite.com/2018/08/27/记录苹果设备唯一账号/</id>
    <published>2018-08-27T03:28:21.000Z</published>
    <updated>2018-09-03T07:47:22.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS获取设备唯一标识符"><a href="#iOS获取设备唯一标识符" class="headerlink" title="iOS获取设备唯一标识符"></a>iOS获取设备唯一标识符</h1><h2 id="UDID-Unique-Device-Identifier"><a href="#UDID-Unique-Device-Identifier" class="headerlink" title="UDID(Unique Device Identifier)"></a>UDID(Unique Device Identifier)</h2><p>苹果IOS设备的唯一识别码, 越狱的设备通过某些工具可以改变设备的UDID,在iOS5.0(2011年8月份)开始，苹果宣布将不再支持uniqueIdentifier方法获取设备的UDID，iOS5以下是可以用的, 在 2013年3月21日苹果已经通知开发者,从2013年5月1日起，访问UIDIDs的程序将不再被审核通过替代的方案是开发者应该使用“在iOS 6中介绍的Vendor或Advertising标示符</p><hr><h2 id="UUID-Universally-Unique-Identifier"><a href="#UUID-Universally-Unique-Identifier" class="headerlink" title="UUID(Universally Unique Identifier)"></a>UUID(Universally Unique Identifier)</h2><p>唯一识别码<em>它是让分布式系统中的所有元素</em>都能有唯一的辨识资讯<em>而不需要透过中央控制端来做辨识资讯的指定</em>苹果公司建议使用UUID为应用生成唯一标识字符串](/uploads/a16006ef33534d3c6a28263d112ebed7/唯一识别码<em>它是让分布式系统中的所有元素</em>都能有唯一的辨识资讯<em>而不需要透过中央控制端来做辨识资讯的指定</em>苹果公司建议使用UUID为应用生成唯一标识字符串</p><hr><h2 id="MAC-Address-Medium-Access-Control"><a href="#MAC-Address-Medium-Access-Control" class="headerlink" title="MAC Address(Medium Access Control)"></a>MAC Address(Medium Access Control)</h2><p>媒体访问控制，或称为物理地址、硬件地址，用来定义网络设备的位置。在OSI模型中，第三层网络层负责 IP地址，第二层数据链路层则负责 MAC地址。因此一个主机会有一个MAC地址，而每个网络位置会有一个专属于它的IP地址。MAC地址是网卡决定的，是固定的</p><hr><h2 id="OPEN-UDID"><a href="#OPEN-UDID" class="headerlink" title="OPEN UDID"></a>OPEN UDID</h2><p>OpenUDID是通过第一个带有OpenUDID SDK包的App生成，如果你完全删除全部带有OpenUDID SDK包的App（比如恢复系统等），那么OpenUDID会重新生成，而且和之前的值会不同，相当于新设备； 优点是没有用到MAC地址；不同设备能够获取各自唯一的识别码，保证了唯一性，可以用于以往UDID的相关用途；从代码分析OpenUDID的获取，识别码获取方便并且保存谨慎。缺点是当将设备上所有使用了OpenUDID方案的应用程序删除，且设备关机重启，xcode彻底清除并重启，重装应用程序去获取OpenUDID，此时OpenUDID变化，与之前不一样了，所有OpenUDID应用卸载后，由UIPasteboard保存的数据即被清除，重装故会重新获取新的OpenUDID。 那么当因为用户干预或者恶意程序，致使UIPasteboard数据清除，从而导致OpenUDID被删除，重装也会获取新的OpenUDID。</p><hr><h2 id="广告标识符-IDFA-identifierForldentifier"><a href="#广告标识符-IDFA-identifierForldentifier" class="headerlink" title="广告标识符(IDFA-identifierForldentifier)"></a>广告标识符(IDFA-identifierForldentifier)</h2><p>是iOS 6中另外一个新的方法，提供了一个方法advertisingIdentifier，通过调用该方法会返回一个NSUUID实例，最后可以获得一个UUID，由系统存储着的。不过即使这是由系统存储的，但是有几种情况下，会重新生成广告标示符。如果用户完全重置系统（(设置程序 -&gt; 通用 -&gt; 还原 -&gt; 还原位置与隐私) ，这个广告标示符会重新生成。另外如果用户明确的还原广告(设置程序-&gt; 通用 -&gt; 关于本机 -&gt; 广告 -&gt; 还原广告标示符) ，那么广告标示符也会重新生成。关于广告标示符的还原，有一点需要注意：如果程序在后台运行，此时用户“还原广告标示符”，然后再回到程序中，此时获取广 告标示符并不会立即获得还原后的标示符。必须要终止程序，然后再重新启动程序，才能获得还原后的广告标示符。</p><hr><h2 id="Vendor标识符-IDFV-identifierForVendor"><a href="#Vendor标识符-IDFV-identifierForVendor" class="headerlink" title="Vendor标识符(IDFV-identifierForVendor)"></a>Vendor标识符(IDFV-identifierForVendor)</h2><p>Vendor是CFBundleIdentifier（反转DNS格式）的前两部分。来自同一个运营商的应用运行在同一个设备上，此属性的值是相同的；不同的运营商应用运行在同一个设备上值不同。 经测试，只要设备上有一个运营商的app，重新安装后的identifierForVendor值不变，如果该运营商的app全部删除，重新安装后的identifierForVendor值改变。</p><hr><h2 id="调研结果"><a href="#调研结果" class="headerlink" title="调研结果"></a>调研结果</h2><p>IMEI 苹果允许的API 但不能获取,不会变化,设备唯一。</p><hr><p>UDID 曾经可以获取,单现在也成为禁止调用的API,不会变化,设备唯一。</p><hr><p>MAC 不能直接通过设备API获取,某种脑洞可以通过WIFI下路由器反馈信息来回传MAC地址,很不方便不会变化,设备唯一</p><hr><p>IDFA 广告标示符,经常容易变,每当用户针对应用程序关闭再开启一次广告追踪就会发生变化</p><hr><p>IDFV 厂商标示符,不太容易变,每当用户卸载完应用厂家旗下所有的应用程序后,再次安装,会发生变化</p><hr><p>NSUUID 苹果API接口,每次获取都变化</p><hr><p>可以确认的是，在众多可选的标识方案里，都不能保证永远不变，所以必须配合钥匙扣使用，有了钥匙扣至少保证，只要用户不刷机，无论是升级系统，还是卸载光所有的应用程序，都不会发生变化,只要有了钥匙扣的辅助，可以说随便选一个标识，只要存入钥匙圈，都能保证不变了。推荐选择了目前来看更加稳定的IDFV</p><p><a href="https://github.com/heliosneverend/HeliosKeychain" target="_blank" rel="noopener">示例代码Demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;iOS获取设备唯一标识符&quot;&gt;&lt;a href=&quot;#iOS获取设备唯一标识符&quot; class=&quot;headerlink&quot; title=&quot;iOS获取设备唯一标识符&quot;&gt;&lt;/a&gt;iOS获取设备唯一标识符&lt;/h1&gt;&lt;h2 id=&quot;UDID-Unique-Device-Identi
      
    
    </summary>
    
      <category term="拾遗" scheme="http://yoursite.com/categories/%E6%8B%BE%E9%81%97/"/>
    
    
      <category term="拾遗" scheme="http://yoursite.com/tags/%E6%8B%BE%E9%81%97/"/>
    
  </entry>
  
  <entry>
    <title>赫夫曼树和赫夫曼编码</title>
    <link href="http://yoursite.com/2017/01/02/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%92%8C%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/"/>
    <id>http://yoursite.com/2017/01/02/赫夫曼树和赫夫曼编码/</id>
    <published>2017-01-02T02:26:59.000Z</published>
    <updated>2018-09-03T09:19:44.977Z</updated>
    
    <content type="html"><![CDATA[<p>给定n个权值作为n个[叶子结点]，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p><p>哈夫曼静态编码：它对需要编码的数据进行两遍扫描：第一遍统计原数据中各字符出现的频率，利用得到的频率值创建哈夫曼树，并必须把树的信息保存起来，即把字符0-255(28=256)的频率值以2-4BYTES的长度顺序存储起来，（用4Bytes的长度存储频率值，频率值的表示范围为0–232-1，这已足够表示大文件中字符出现的频率了）以便解压时创建同样的哈夫曼树进行解压；第二遍则根据第一遍扫描得到的哈夫曼树进行编码，并把编码后得到的码字存储起来。</p><p>哈夫曼动态编码：动态哈夫曼编码使用一棵动态变化的哈夫曼树，对第t+1个字符的编码是根据原始数据中前t个字符得到的哈夫曼树来进行的，编码和解码使用相同的初始哈夫曼树，每处理完一个字符，编码和解码使用相同的方法修改哈夫曼树，所以没有必要为解码而保存哈夫曼树的信息。编码和解码一个字符所需的时间与该字符的编码长度成正比，所以动态哈夫曼编码可实时进行</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定n个权值作为n个[叶子结点]，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。&lt;/p&gt;
&lt;p&gt;哈夫曼静态编码：它对需要编码的数据进行两遍扫描：第
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="http://yoursite.com/2017/01/01/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2017/01/01/二叉树/</id>
    <published>2017-01-01T12:03:59.000Z</published>
    <updated>2018-09-03T09:19:28.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树（Binary Tree）是n（n&gt;=0）个结点的有限集合，该集合或者为空集（空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。<br>左子树和右子树位置不可颠倒。</p><h2 id="二叉树的形态："><a href="#二叉树的形态：" class="headerlink" title="二叉树的形态："></a>二叉树的形态：</h2><p><img src="二叉树1.png" alt=""></p><h3 id="斜二叉树"><a href="#斜二叉树" class="headerlink" title="斜二叉树"></a>斜二叉树</h3><p>子树全部在一个方向</p><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>满二叉树的特点有：<br>叶子只能出现在最下一层。<br>非叶子结点的度一定是2。<br>在同样深度的二叉树中，满二叉树的结点个数一定最多，同时叶子也是最多。</p><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><h2 id="二叉树的存储"><a href="#二叉树的存储" class="headerlink" title="二叉树的存储"></a>二叉树的存储</h2><p>二叉链表</p><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>二叉树的遍历(traversing binary tree)是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。</p><p>二叉树的遍历方式可以很多，如果我们限制了从左到右的习惯方式，那么主要就分为一下四种：</p><p>前序遍历<br>中序遍历<br>后序遍历<br>层序遍历</p><h3 id="前序遍历："><a href="#前序遍历：" class="headerlink" title="前序遍历："></a>前序遍历：</h3><p>若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树<br><img src="二叉树2.png" alt=""></p><h3 id="中序遍历："><a href="#中序遍历：" class="headerlink" title="中序遍历："></a>中序遍历：</h3><p>若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树。<br><img src="二叉树3.png" alt=""></p><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后访问根结点。<br><img src="二叉树4.png" alt=""></p><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。<br><img src="二叉树5.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h2&gt;&lt;p&gt;二叉树（Binary Tree）是n（n&amp;gt;=0）个结点的有限集合，该集合或者为空集（空二叉树），或者由一个根结点和两棵互不相交
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>树及存储结构</title>
    <link href="http://yoursite.com/2016/12/03/%E6%A0%91%E5%8F%8A%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2016/12/03/树及存储结构/</id>
    <published>2016-12-03T08:03:46.000Z</published>
    <updated>2018-09-03T09:15:02.924Z</updated>
    
    <content type="html"><![CDATA[<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>不同于1对1的线性数据结构，树是一种一对多的存储结构。</p><p>树(Tree)是n(n&gt;=0)个结点的有限集。当n=0时成为空树，在任意一棵非空树中：</p><p>有且仅有一个特定的称为根(Root)的结点；<br>当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集T1、T2、…、Tm，其中每一个集合本身又是一棵树，并且称为根的子树(SubTree)。<br><img src="树1.png" alt=""></p><h2 id="节点分类："><a href="#节点分类：" class="headerlink" title="节点分类："></a>节点分类：</h2><p>上面图片中，每一个圈圈我们就称为树的一个结点。结点拥有的子树数称为结点的度-(Degree)，树的度 取树内各结点的度的最大值：</p><p>度为0的结点称为叶结点(Leaf)或终端结点；<br>度不为0的结点称为分支结点或非终端结点，除根结点外，分支结点也称为内部结点。<br><img src="树2.png" alt=""></p><h2 id="节点间的关系："><a href="#节点间的关系：" class="headerlink" title="节点间的关系："></a>节点间的关系：</h2><p>结点的子树的根称为结点的孩子(Child)，相应的，该结点称为孩子的双亲(Parent)，同一双亲的孩子之间互称为兄弟(Sibling)。<br>结点的祖先是从根到该结点所经分支上的所有结点。</p><h2 id="节点的层次："><a href="#节点的层次：" class="headerlink" title="节点的层次："></a>节点的层次：</h2><p>结点的层次(Level)从根开始定一起，根为第一层，根的孩子为第二层。<br>其双亲在同一层的结点互为堂兄弟。<br>树中结点的最大层次称为树的深度(Depth)或高度</p><h2 id="有序树："><a href="#有序树：" class="headerlink" title="有序树："></a>有序树：</h2><p>若将树中每个结点的各子树看成是从左到右有次序的(即不能互换)，则称该树为有序树(Ordered Tree)；<br>否则称为无序树(UnorderedTree)。</p><h2 id="森林："><a href="#森林：" class="headerlink" title="森林："></a>森林：</h2><p>森林是m（m &gt;= 0）棵互不相交的树的集合。<br>对树中的每个结点而言，其子树的集合即为森林。</p><h2 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h2><p>双亲孩子表示法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;树&quot;&gt;&lt;a href=&quot;#树&quot; class=&quot;headerlink&quot; title=&quot;树&quot;&gt;&lt;/a&gt;树&lt;/h2&gt;&lt;p&gt;不同于1对1的线性数据结构，树是一种一对多的存储结构。&lt;/p&gt;
&lt;p&gt;树(Tree)是n(n&amp;gt;=0)个结点的有限集。当n=0时成为空树，在任意
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>字符串匹配的BF算法和KMP算法</title>
    <link href="http://yoursite.com/2016/10/12/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%9A%84BF%E7%AE%97%E6%B3%95%E5%92%8CKMP%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2016/10/12/字符串匹配的BF算法和KMP算法/</id>
    <published>2016-10-12T07:19:22.000Z</published>
    <updated>2018-09-03T09:12:46.835Z</updated>
    
    <content type="html"><![CDATA[<p>BF算法，即暴风(Brute Force)算法，是普通的模式匹配算法。</p><p>BF算法的思想就是将目标串S的第一个字符与模式串T的第一个字符进行匹配，若相等，则继续比较S的第二个字符和 T的第二个字符；若不相等，则比较S的第二个字符和T的第一个字符，依次比较下去，直到得出最后的匹配结果。BF算法是一种蛮力算法。</p><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">KMP算法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;BF算法，即暴风(Brute Force)算法，是普通的模式匹配算法。&lt;/p&gt;
&lt;p&gt;BF算法的思想就是将目标串S的第一个字符与模式串T的第一个字符进行匹配，若相等，则继续比较S的第二个字符和 T的第二个字符；若不相等，则比较S的第二个字符和T的第一个字符，依次比较下去，直
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>栈和队列</title>
    <link href="http://yoursite.com/2016/09/03/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2016/09/03/栈和队列/</id>
    <published>2016-09-03T00:29:31.000Z</published>
    <updated>2018-09-03T09:11:39.988Z</updated>
    
    <content type="html"><![CDATA[<p>栈是一个先进后出的线性表。它要求只在表尾(栈头Top)进行删除和插入操作。<br>线性表有两种存储形式 ，所以栈也分为顺序存储结构和链式存储结构。<br>栈常用的是顺序存储结构。<br>这里定义了一个顺序存储的栈，它包含了三个元素：base,top,stackSize。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    ElemType *base;  // 指向栈底的指针变量</span><br><span class="line">    ElemType *top;     //指向栈顶的指针变量</span><br><span class="line">    int stackSize;   // 指示栈的当前可使用的最大容量</span><br><span class="line">&#125;sqStack;</span><br></pre></td></tr></table></figure></p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>同样作为线性表的一种，是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。<br>与栈相反，队列是先进先出。<br>队列一般用链式存储结构实现，简称链队列。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;栈是一个先进后出的线性表。它要求只在表尾(栈头Top)进行删除和插入操作。&lt;br&gt;线性表有两种存储形式 ，所以栈也分为顺序存储结构和链式存储结构。&lt;br&gt;栈常用的是顺序存储结构。&lt;br&gt;这里定义了一个顺序存储的栈，它包含了三个元素：base,top,stackSize。&lt;b
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>双向链表</title>
    <link href="http://yoursite.com/2016/08/16/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2016/08/16/双向链表/</id>
    <published>2016-08-16T10:29:31.000Z</published>
    <updated>2018-09-03T09:10:40.481Z</updated>
    
    <content type="html"><![CDATA[<h2 id="双向链表结构"><a href="#双向链表结构" class="headerlink" title="双向链表结构"></a>双向链表结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef structDualNode &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    struct DualNode*prior;  //前驱结点</span><br><span class="line">    struct DualNode*next;   //后继结点</span><br><span class="line">&#125; DualNode, *DuLinkList;</span><br></pre></td></tr></table></figure><p><img src="双向链表1.png" alt=""><br>既然单链表可以有循环链表，那么双向链表当然也可以有:<br><img src="双向链表2.png" alt=""><br>双向链表的插入操作：<br><img src="双向链表3.png" alt=""><br>s-&gt;next = p;<br>s-&gt;prior = p-&gt;prior;<br>p-&gt;prior-&gt;next = s;<br>p-&gt;prior = s;<br>双向链表的删除操作<br><img src="双向链表4.png" alt=""><br>p-&gt;prior-&gt;next = p-&gt;next;<br>p-&gt;next-&gt;prior = p-&gt;prior;<br>free(p);</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;双向链表结构&quot;&gt;&lt;a href=&quot;#双向链表结构&quot; class=&quot;headerlink&quot; title=&quot;双向链表结构&quot;&gt;&lt;/a&gt;双向链表结构&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>线性表</title>
    <link href="http://yoursite.com/2016/07/16/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>http://yoursite.com/2016/07/16/线性表/</id>
    <published>2016-07-16T00:19:31.000Z</published>
    <updated>2018-09-03T08:57:22.651Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线性表定义："><a href="#线性表定义：" class="headerlink" title="线性表定义："></a>线性表定义：</h2><p>作为常见的一种数据结构，线性表是由0个或者多个数据元素组成的有限序列。<br><img src="线性表.png" alt=""><br>a1无前驱元素，a1是a2的前驱元素，a2是a1的后继元素，an无后继元素；<br>当n=0时候，称为空表。</p><h2 id="线性表操作："><a href="#线性表操作：" class="headerlink" title="线性表操作："></a>线性表操作：</h2><p>InitList(<em>L)：初始化并建立一个空的线性表<br>ListEmpty(</em>L): 判断线性表是否为空表<br>ClearList(<em>L): 将线性表清空<br>GetElem(</em>L, i, <em>e): 将线性表L中的第i个位置的元素返回给e<br>LocateElem(</em> L,<em>e):在线性表L中查找与给定值e相等的元素，查找成功，则返回该元素的序号，否则返回0表示失败<br>ListInsert(</em>L, i, <em>e)<br>ListDelete(</em>L, i, <em>e)<br>ListLength(</em>L)：返回线性表元素个数</p><h2 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h2><p>在读取数据时，不论是哪个位置，时间复杂度都是O(1)；<br>而在插入和删除的时候，最好情况，即插入或者删除刚好是最后一个数据的时候，复杂度是O(1),最坏情况，即插入或者删除刚好是第一个数据的时候，事件复杂度是O(n)，平均时间复杂度是O((n-1)/2)，也就是O(n)。</p><p>综上：<br>线性表的顺序存储结构。适合元素个数比较稳定，不经常插入或者删除元素，更多的是读取数据的应用场景。</p><p>优点：<br> 无须为表示表中元素之间的逻辑关系而增加额外的存储空间。<br> 可以快速地存取表中任意位置的元素。<br>缺点：<br> 插入和删除操作需要移动大量元素。<br> 当线性表长度变化较大时，难以确定存储空间的容量。<br> 容易造成存储空间的“碎片”。</p><h2 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="headerlink" title="线性表的链式存储结构"></a>线性表的链式存储结构</h2><p>线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以存在内存中未被占用的任意位置。</p><p>比起顺序存储结构每个数据元素只需要存储一个位置就可以了。现在链式存储结构中，除了要存储数据元素信息外，还要存储它的后继元素的存储地址（指针）。</p><p>也就是说除了存储其本身的信息外，还需存储一个指示其直接后继的存储位置的信息</p><p>我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称为指针或链。这两部分信息组成数据元素称为存储映像，称为结点(Node)。<br><img src="节点.png" alt=""><br>n个结点链接成一个链表，即为线性表(a1, a2, a3, …, an)的链式存储结构。<br>因为此链表的每个结点中只包含一个指针域，所以叫做单链表。</p><p>我们把链表中的第一个结点的存储位置叫做头指针，最后一个结点指针为空(NULL)。<br>头指针：</p><p>头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针。<br>头指针具有标识作用，所以常用头指针冠以链表的名字（指针变量的名字）。<br>无论链表是否为空，头指针均不为空。<br>头指针是链表的必要元素。<br>头结点：</p><p>头结点是为了操作的统一和方便而设立的，放在第一个元素的结点之前，其数据域一般无意义（但也可以用来存放链表的长度）。<br>有了头结点，对在第一元素结点前插入结点和删除第一结点起操作与其它结点的操作就统一了。<br>头结点不一定是链表的必须要素。<br><img src="单链表图例.png" alt=""><br><img src="空链表图例.png" alt=""><br>如果没有头结点，则头指针直接指向NULL<br>单链表的插入<br><img src="单链表的插入.png" alt=""><br>单链表的删除<br><img src="单链表的删除.png" alt=""><br>单链表的数据插入和删除，时间复杂度都是O(n),但是如果在某个位置插入多个数据，顺序链表每次操作复杂度都是O（n），而单链表除了第一次操作为O(n)外，后面操作复杂度都是O（1）<br>综上：对于插入或者删除数据频繁的操作，单链表的效率就很明显了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;线性表定义：&quot;&gt;&lt;a href=&quot;#线性表定义：&quot; class=&quot;headerlink&quot; title=&quot;线性表定义：&quot;&gt;&lt;/a&gt;线性表定义：&lt;/h2&gt;&lt;p&gt;作为常见的一种数据结构，线性表是由0个或者多个数据元素组成的有限序列。&lt;br&gt;&lt;img src=&quot;线性表.p
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>循环链表</title>
    <link href="http://yoursite.com/2016/07/04/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2016/07/04/循环链表/</id>
    <published>2016-07-04T04:09:25.000Z</published>
    <updated>2018-09-03T09:07:57.954Z</updated>
    
    <content type="html"><![CDATA[<p>对于单链表，由于每个结点只存储了向后的指针，到了尾部标识就停止了向后链的操作。也就是说，按照这样的方式，只能索引后继结点不能索引前驱结点。<br>这会带来什么问题呢？<br>例如不从头结点出发，就无法访问到全部结点。<br>事实上要解决这个问题也并不麻烦，只需要将单链表中终端结点的指针端由空指针改为指向头结点，问题就结了。<br>将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表成为单循环链表，简称循环链表<br><img src="单循环链表示意图.png" alt=""><br>注：这里并不是说循环链表一定要有头结点。</p><p>其实循环链表的单链表的主要差异就在于循环的判断空链表的条件上，原来判断head-&gt;next是否为null，现在则是head-&gt;next是否等于head</p><p>约瑟夫问题：<br>据说著名犹太历史学家 Josephus有过以下的故事：在罗马人占领乔塔帕特后，39个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。<br>然而Josephus和他的朋友并不想遵从，Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于单链表，由于每个结点只存储了向后的指针，到了尾部标识就停止了向后链的操作。也就是说，按照这样的方式，只能索引后继结点不能索引前驱结点。&lt;br&gt;这会带来什么问题呢？&lt;br&gt;例如不从头结点出发，就无法访问到全部结点。&lt;br&gt;事实上要解决这个问题也并不麻烦，只需要将单链表中终
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>静态链表</title>
    <link href="http://yoursite.com/2016/07/03/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2016/07/03/静态链表/</id>
    <published>2016-07-03T05:09:25.000Z</published>
    <updated>2018-09-03T09:19:50.176Z</updated>
    
    <content type="html"><![CDATA[<h2 id="静态链表说明"><a href="#静态链表说明" class="headerlink" title="静态链表说明"></a>静态链表说明</h2><p>用数组描述的链表称之为静态链表。<br>这种描述方法叫做游标实现法。<br><img src="静态链表.png" alt=""><br>我们对数组的第一个和最后一个元素做特殊处理，他们的data不存放数据。<br>我们通常把未使用的数组元素称为备用链表。<br>数组的第一个元素，即下标为0的那个元素的cur就存放备用链表的第一个结点的下标。即第0个元素的游标为5<br>数组的最后一个元素，即下标为MAXSIZE-1的cur则存放第一个有数值的元素的下标，相当于单链表中的头结点作用。即第999个元素游标为1</p><p>静态链表存储结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define MAXSIZE 1000</span><br><span class="line">typedefstruct</span><br><span class="line">&#123;</span><br><span class="line">ElemTypedata;  // 数据</span><br><span class="line">intcur;        // 游标（Cursor）</span><br><span class="line">&#125; Component, StaticLinkList[MAXSIZE];</span><br></pre></td></tr></table></figure></p><h2 id="静态链表的插入："><a href="#静态链表的插入：" class="headerlink" title="静态链表的插入："></a>静态链表的插入：</h2><p>每当进行插入时，可以从备用链表上取得第一个结点作为待插入的新结点。</p><p>要将B元素插入到A元素后面：<br><img src="静态链表的插入.png" alt=""><br>优点：</p><p>在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点。<br>缺点：</p><p>没有解决连续存储分配（数组）带来的表长难以确定的问题。<br>失去了顺序存储结构随机存取的特性。</p><h2 id="问题：如何快速找到单向链表的中间节点？"><a href="#问题：如何快速找到单向链表的中间节点？" class="headerlink" title="问题：如何快速找到单向链表的中间节点？"></a>问题：如何快速找到单向链表的中间节点？</h2><p>方法1. 从头遍历单向链表，得到链表总长度L，然后再从头遍历L/2长度拿到中间节点，程序执行次数3L/2</p><p>方法2. 利用快慢指针，设置两个指针search和mid都指向单向链表的头节点。其中search指针的移动速度是mid的两倍。当search指针指向末尾节点的时候，mid指针就恰好在中间位置。也即标尺的思想。程序执行次数L/2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Status GetMidNode(LinkList L, ElemType *e) &#123;</span><br><span class="line">    LinkList search, mid;</span><br><span class="line">    mid = search = L;</span><br><span class="line">    while (search-&gt;next != NULL) &#123;</span><br><span class="line">        if (search-&gt;next-&gt;next != NULL) &#123;</span><br><span class="line">            search = search-&gt;next-&gt;next;</span><br><span class="line">            mid = mid-&gt;next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                search = search-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        *e = mid-&gt;data;</span><br><span class="line">        return OK;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="问题：如何判断单向链表是否有环？"><a href="#问题：如何判断单向链表是否有环？" class="headerlink" title="问题：如何判断单向链表是否有环？"></a>问题：如何判断单向链表是否有环？</h2><p>方法一：使用p、q两个指针，p总是向前走，但q每次都从头开始走，对于每个节点，看p走的步数是否和q一样。如图，当p从6走到3时，用了6步，此时若q从head出发，则只需两步就到3，因而步数不等，出现矛盾，存在环。<br>方法二：使用p、q两个指针，p每次向前走一步，q每次向前走两步，若在某个时候p == q，则存在环。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;静态链表说明&quot;&gt;&lt;a href=&quot;#静态链表说明&quot; class=&quot;headerlink&quot; title=&quot;静态链表说明&quot;&gt;&lt;/a&gt;静态链表说明&lt;/h2&gt;&lt;p&gt;用数组描述的链表称之为静态链表。&lt;br&gt;这种描述方法叫做游标实现法。&lt;br&gt;&lt;img src=&quot;静态链表.p
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>单向链表的整表操作</title>
    <link href="http://yoursite.com/2016/06/13/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E6%95%B4%E8%A1%A8%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2016/06/13/单向链表的整表操作/</id>
    <published>2016-06-13T11:11:25.000Z</published>
    <updated>2018-09-03T09:00:11.540Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单链表的整表创建："><a href="#单链表的整表创建：" class="headerlink" title="单链表的整表创建："></a>单链表的整表创建：</h2><h3 id="1-头插法"><a href="#1-头插法" class="headerlink" title="1.头插法"></a>1.头插法</h3><p>头插法从一个空表开始，生成新结点，读取数据存放到新结点的数据域中，然后将新结点插入到当前链表的表头上，直到结束为止。</p><p>简单来说，就是把新加进的元素放在表头后的第一个位置：<br>先让新节点的next指向头节点之后<br>然后让表头的next指向新节点<br><img src="头插法.png" alt=""><br>缺点是： 链表顺序跟要插入的数据顺序是反着的。</p><h3 id="2-尾插法"><a href="#2-尾插法" class="headerlink" title="2.尾插法"></a>2.尾插法</h3><p><img src="尾插法.png" alt=""></p><h2 id="单链表的整表删除："><a href="#单链表的整表删除：" class="headerlink" title="单链表的整表删除："></a>单链表的整表删除：</h2><p>当我们不打算使用这个单链表时，我们需要把它销毁，其实也就是在内存中将它释放掉，以便于留出空间给其他程序或软件使用。</p><p>单链表整表删除的算法思路如下：</p><p>声明结点p和q；<br>将第一个结点赋值给p，下一结点赋值给q；<br>循环执行释放p和将q赋值给p的操作；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;单链表的整表创建：&quot;&gt;&lt;a href=&quot;#单链表的整表创建：&quot; class=&quot;headerlink&quot; title=&quot;单链表的整表创建：&quot;&gt;&lt;/a&gt;单链表的整表创建：&lt;/h2&gt;&lt;h3 id=&quot;1-头插法&quot;&gt;&lt;a href=&quot;#1-头插法&quot; class=&quot;header
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>度量算法效率的方法</title>
    <link href="http://yoursite.com/2016/05/03/%E5%BA%A6%E9%87%8F%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/05/03/度量算法效率的方法/</id>
    <published>2016-05-03T01:10:25.000Z</published>
    <updated>2018-09-03T08:07:18.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。</p><p>算法的时间复杂度，也就是算法的时间量度，记做T(n)=O(f(n))。<br>他表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。其中，f(n)是问题的规模n的某个函数。</p><p>这样用大写字母O来体现算法时间复杂度的记法，常称之为大O记法。</p><h2 id="如何推导时间复杂度："><a href="#如何推导时间复杂度：" class="headerlink" title="如何推导时间复杂度："></a>如何推导时间复杂度：</h2><p>用常数1来取代运行时间中所有加法常数，如：1+2+3 = 1,记为O(1)<br>在修改后的运行次数函数中，只保留最高阶项，如：n+n^2 = n^2,记为O(n^2)<br>如果最高阶项存在且不是1，则去除与这个项相乘的常数，如：3n^2 = n^2,记为O(n^2)</p><h2 id="计算下面程序的时间复杂度"><a href="#计算下面程序的时间复杂度" class="headerlink" title="计算下面程序的时间复杂度"></a>计算下面程序的时间复杂度</h2><p>例题1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">int b = 0;</span><br><span class="line">int c = a + b;</span><br><span class="line">printf(&quot;hello world&quot;);</span><br><span class="line">答案 O(1)</span><br></pre></td></tr></table></figure></p><p>例题2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0 ; i &lt; 100; i++) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">答案 O(n)</span><br></pre></td></tr></table></figure></p><p>例题3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0 ; i &lt; 100; i++) &#123;</span><br><span class="line">    for (int j = 0 ; j &lt; 100; j++) &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">答案:O(n^2)</span><br></pre></td></tr></table></figure></p><p>例题4<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0 ; i &lt; 100; i++) &#123;</span><br><span class="line">    for (int j = i ; j &lt; i; j++) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//分析：执行次数 = n + (n-1) + (n-2) +...+1 = n * (n + 1) / 2 = (n^2) / 2 + n / 2</span><br><span class="line">答案: O(n^2)</span><br></pre></td></tr></table></figure></p><p>例题5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    int i = 1, n = 100;</span><br><span class="line">    while (i &lt; n) &#123;</span><br><span class="line">        i = i * 2;</span><br><span class="line">    &#125;</span><br><span class="line">//分析：退出条件是2*x = = n，可以得到x = log(2)n -- 以2为底，n的对数</span><br><span class="line">答案:O(logn)</span><br></pre></td></tr></table></figure></p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>算法的空间复杂度：通过计算算法所需的存储空间实现，算法的空间复杂度的计算公式记为：S(n) = O(f(n)),其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;时间复杂度&quot;&gt;&lt;a href=&quot;#时间复杂度&quot; class=&quot;headerlink&quot; title=&quot;时间复杂度&quot;&gt;&lt;/a&gt;时间复杂度&lt;/h1&gt;&lt;p&gt;在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
