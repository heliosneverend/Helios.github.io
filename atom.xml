<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Heliso</title>
  
  <subtitle>记录平时学习到的东西</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-03T06:25:25.570Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zyf</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>黑魔法Clang Attribute</title>
    <link href="http://yoursite.com/2018/09/03/%E9%BB%91%E9%AD%94%E6%B3%95Clang%20Attribute/"/>
    <id>http://yoursite.com/2018/09/03/黑魔法Clang Attribute/</id>
    <published>2018-09-03T03:07:16.000Z</published>
    <updated>2018-09-03T06:25:25.570Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Clang-Attribute-说明"><a href="#Clang-Attribute-说明" class="headerlink" title="Clang Attribute 说明"></a>Clang Attribute 说明</h1><p>Clang Attribute 是Clang提供的一种源码注解,一般以<strong>attribute</strong>(xxx) 的形式出现在代码中</p><h1 id="constructor-destructor"><a href="#constructor-destructor" class="headerlink" title="constructor / destructor"></a>constructor / destructor</h1><p>构造器和析构器，加上这两个属性的函数会在分别在可执行文件（或 shared library）load 和 unload 时被调用，可以理解为在 main() 函数调用前和 return 后执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((constructor))</span><br><span class="line">static void beforeMain(void) &#123;</span><br><span class="line">NSLog(@&quot;beforeMain&quot;);</span><br><span class="line">&#125;</span><br><span class="line">__attribute__((destructor))</span><br><span class="line">static void afterMain(void) &#123;</span><br><span class="line">NSLog(@&quot;afterMain&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">NSLog(@&quot;main&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Console:</span><br><span class="line">// &quot;beforeMain&quot; -&gt; &quot;main&quot; -&gt; &quot;afterMain&quot;</span><br></pre></td></tr></table></figure></p><p>constructor 和 +load 都是在 main 函数执行前调用，但 +load 比 constructor 更加早一丢丢，因为 dyld（动态链接器，程序的最初起点）在加载 image（可以理解成 Mach-O 文件）时会先通知 objc runtime 去加载其中所有的类，每加载一个类时，它的 +load 随之调用，全部加载完成后，dyld 才会调用这个 image 中所有的 constructor 方法。<br>所以 constructor 是一个干坏事的绝佳时机：<br>所有 Class 都已经加载完成<br>main 函数还未执行<br>无需像 +load 还得挂载在一个 Class 中<br>FDStackView 的 FDStackViewPatchEntry 方法便是使用的这个时机来实现偷天换日的伎俩。<br>PS：若有多个 constructor 且想控制优先级的话，可以写成 <strong>attribute</strong>((constructor(101)))，里面的数字越小优先级越高，1 ~ 100 为系统保留。</p><h1 id="enable-if"><a href="#enable-if" class="headerlink" title="enable_if"></a>enable_if</h1><p>这个属性只能用在 C 函数上，可以用来实现参数的静态检查：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static void printValidAge(int age)</span><br><span class="line">__attribute__((enable_if(age &gt; 0 &amp;&amp; age &lt; 120, &quot;你火星人？&quot;))) &#123;</span><br><span class="line">printf(&quot;%d&quot;, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它表示调用这个函数时必须满足 age &gt; 0 &amp;&amp; age &lt; 120 才被允许，于是乎：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">printValidAge(26); // √</span><br><span class="line">printValidAge(150); // &lt;--- Compile Error</span><br><span class="line">printValidAge(-1); // &lt;--- Compile Error</span><br></pre></td></tr></table></figure></p><h1 id="cleanup"><a href="#cleanup" class="headerlink" title="cleanup"></a>cleanup</h1><p>声明到一个变量上，当这个变量作用域结束时，调用指定的一个函数，Reactive Cocoa 用这个特性实现了神奇的 @onExit</p><h1 id="overloadable"><a href="#overloadable" class="headerlink" title="overloadable"></a>overloadable</h1><p>用于 C 函数，可以定义若干个函数名相同，但参数不同的方法，调用时编译器会自动根据参数选择函数原型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((overloadable)) void logAnything(id obj) &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, obj);</span><br><span class="line">&#125;</span><br><span class="line">__attribute__((overloadable)) void logAnything(int number) &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, @(number));</span><br><span class="line">&#125;</span><br><span class="line">__attribute__((overloadable)) void logAnything(CGRect rect) &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, NSStringFromCGRect(rect));</span><br><span class="line">&#125;</span><br><span class="line">// Tests</span><br><span class="line">logAnything(@[@&quot;1&quot;, @&quot;2&quot;]);</span><br><span class="line">logAnything(233);</span><br><span class="line">logAnything(CGRectMake(1, 2, 3, 4));</span><br></pre></td></tr></table></figure></p><h1 id="objc-subclassing-restricted"><a href="#objc-subclassing-restricted" class="headerlink" title="objc_subclassing_restricted"></a>objc_subclassing_restricted</h1><p>使用这个属性可以定义一个不可被继承的类,只需在@interface前面加上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((objc_subclassing_restricted))即可</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">__attribute__((objc_subclassing_restricted))</span><br><span class="line">@interface Person : NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@interface Child: Person //Cannot subclass a class that was declared with the &apos;objc_subclassing_restricted&apos; attribute</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h1 id="objc-requires-super"><a href="#objc-requires-super" class="headerlink" title="objc_requires_super"></a>objc_requires_super</h1><p>NS_REQUIRES_SUPER 子类继承该方法时需要调用 super 否则给出编译警告<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">- (void)fatherMethod __attribute__((objc_requires_super));</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Child</span><br><span class="line">- (void)fatherMethod &#123;</span><br><span class="line"> //Method possibly missing a [super fatherMethod] call</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h1 id="objc-runtime-name"><a href="#objc-runtime-name" class="headerlink" title="objc_runtime_name"></a>objc_runtime_name</h1><p>用于 @interface 或 @protocol，将类或协议的名字在编译时指定成另一个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((objc_runtime_name(&quot;SarkGay&quot;)))</span><br><span class="line">@interface Sark : NSObject</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;, NSStringFromClass([Sark class])); // &quot;SarkGay&quot;</span><br></pre></td></tr></table></figure></p><p>所有直接使用这个类名的地方都会被替换（唯一要注意的是这时用反射就不对了），最简单粗暴的用处就是去做个类名混淆：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((objc_runtime_name(&quot;40ea43d7629d01e4b8d6289a132482d0dd5df4fa&quot;)))</span><br><span class="line">@interface SecretClass : NSObject</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>还能用数字开头，怕不怕 - -，假如写个脚本把每个类前加个随机生成的 objc_runtime_name，岂不是最最精简版的代码混淆就完成了呢…</p><p>它是我所了解的唯一一个对 objc 运行时类结构有影响的 attribute，通过编码类名可以在编译时注入一些信息，被带到运行时之后，再反解出来，这就相当于开设了一条秘密通道，打通了写码时和运行时。脑洞一下，假如把这个 attribute 定义成宏，以 annotation 的形式完成某些功能，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// @singleton 包裹了 __attribute__((objc_runtime_name(...)))</span><br><span class="line">// 将类名改名成 &quot;SINGLETON_Sark_sharedInstance&quot;</span><br><span class="line">@singleton(Sark, sharedInstance)</span><br><span class="line">@interface Sark : NSObject</span><br><span class="line">+ (instancetype)sharedInstance;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>在运行时用 <strong>attribute</strong>((constructor)) 获取入口时机，用 runtime 找到这个类，反解出 “sharedInstance” 这个 selector 信息，动态将 + alloc，- init 等方法替换，返回 + sharedInstance 单例。</p><h1 id="objc-boxable"><a href="#objc-boxable" class="headerlink" title="objc_boxable"></a>objc_boxable</h1><p>Objective-C 中的 @(…) 语法糖可以将基本数据类型 box 成 NSNumber 对象，假如想 box 一个 struct 类型或是 union 类型成 NSValue 对象，可以使用这个属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef struct __attribute__((objc_boxable)) &#123;</span><br><span class="line">CGFloat x, y, width, height;</span><br><span class="line">&#125; XXRect;</span><br></pre></td></tr></table></figure></p><p>这样一来，XXRect 就具备被 box 的能力：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CGRect rect1 = &#123;1, 2, 3, 4&#125;;</span><br><span class="line">NSValue *value1 = @(rect1); // &lt;--- Compile Error</span><br><span class="line">XXRect rect2 = &#123;1, 2, 3, 4&#125;;</span><br><span class="line">NSValue *value2 = @(rect2); // √</span><br></pre></td></tr></table></figure></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://blog.sunnyxx.com/2016/05/14/clang-attributes/" target="_blank" rel="noopener">参考地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Clang-Attribute-说明&quot;&gt;&lt;a href=&quot;#Clang-Attribute-说明&quot; class=&quot;headerlink&quot; title=&quot;Clang Attribute 说明&quot;&gt;&lt;/a&gt;Clang Attribute 说明&lt;/h1&gt;&lt;p&gt;Clang 
      
    
    </summary>
    
    
      <category term="OC" scheme="http://yoursite.com/tags/OC/"/>
    
  </entry>
  
  <entry>
    <title>React入门</title>
    <link href="http://yoursite.com/2018/09/03/React%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2018/09/03/React入门/</id>
    <published>2018-09-03T02:50:42.000Z</published>
    <updated>2018-09-03T03:03:34.994Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="React-Native" scheme="http://yoursite.com/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>swift和OC返回指定页面</title>
    <link href="http://yoursite.com/2018/08/27/swift%E5%92%8COC%E8%BF%94%E5%9B%9E%E6%8C%87%E5%AE%9A%E9%A1%B5%E9%9D%A2/"/>
    <id>http://yoursite.com/2018/08/27/swift和OC返回指定页面/</id>
    <published>2018-08-27T08:09:05.000Z</published>
    <updated>2018-08-31T09:18:34.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VC-多层-push后回到指定页面的几种方法"><a href="#VC-多层-push后回到指定页面的几种方法" class="headerlink" title="VC 多层 push后回到指定页面的几种方法"></a>VC 多层 push后回到指定页面的几种方法</h1><p>写一个ViewController的类方法,核心方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func backToViewController(className: String, animated: Bool) &#123;  </span><br><span class="line">        if ((self.navigationController) != nil) &#123;  </span><br><span class="line">            let controllers: Array = (self.navigationController?.viewControllers) ?? []  </span><br><span class="line">            let res = controllers.filter &#123; (item) -&gt; Bool in  </span><br><span class="line">                guard let aClass = NSClassFromString(className) else &#123;  </span><br><span class="line">                return false  </span><br><span class="line">            &#125;  </span><br><span class="line">            return item.isKind(of: aClass)  </span><br><span class="line">        &#125;  </span><br><span class="line">        if (res.count &gt; 0) &#123;  </span><br><span class="line">            self.navigationController?.popToViewController(res[0], animated: animated)  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/heliosneverend/popToViewController.git" target="_blank" rel="noopener">示例代码Demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;VC-多层-push后回到指定页面的几种方法&quot;&gt;&lt;a href=&quot;#VC-多层-push后回到指定页面的几种方法&quot; class=&quot;headerlink&quot; title=&quot;VC 多层 push后回到指定页面的几种方法&quot;&gt;&lt;/a&gt;VC 多层 push后回到指定页面的几种
      
    
    </summary>
    
    
      <category term="function" scheme="http://yoursite.com/tags/function/"/>
    
  </entry>
  
  <entry>
    <title>记录苹果设备唯一账号</title>
    <link href="http://yoursite.com/2018/08/27/%E8%AE%B0%E5%BD%95%E8%8B%B9%E6%9E%9C%E8%AE%BE%E5%A4%87%E5%94%AF%E4%B8%80%E8%B4%A6%E5%8F%B7/"/>
    <id>http://yoursite.com/2018/08/27/记录苹果设备唯一账号/</id>
    <published>2018-08-27T03:28:21.000Z</published>
    <updated>2018-08-31T08:17:01.630Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS获取设备唯一标识符"><a href="#iOS获取设备唯一标识符" class="headerlink" title="iOS获取设备唯一标识符"></a>iOS获取设备唯一标识符</h1><h2 id="UDID-Unique-Device-Identifier"><a href="#UDID-Unique-Device-Identifier" class="headerlink" title="UDID(Unique Device Identifier)"></a>UDID(Unique Device Identifier)</h2><p>苹果IOS设备的唯一识别码, 越狱的设备通过某些工具可以改变设备的UDID,在iOS5.0(2011年8月份)开始，苹果宣布将不再支持uniqueIdentifier方法获取设备的UDID，iOS5以下是可以用的, 在 2013年3月21日苹果已经通知开发者,从2013年5月1日起，访问UIDIDs的程序将不再被审核通过替代的方案是开发者应该使用“在iOS 6中介绍的Vendor或Advertising标示符</p><hr><h2 id="UUID-Universally-Unique-Identifier"><a href="#UUID-Universally-Unique-Identifier" class="headerlink" title="UUID(Universally Unique Identifier)"></a>UUID(Universally Unique Identifier)</h2><p>唯一识别码<em>它是让分布式系统中的所有元素</em>都能有唯一的辨识资讯<em>而不需要透过中央控制端来做辨识资讯的指定</em>苹果公司建议使用UUID为应用生成唯一标识字符串](/uploads/a16006ef33534d3c6a28263d112ebed7/唯一识别码<em>它是让分布式系统中的所有元素</em>都能有唯一的辨识资讯<em>而不需要透过中央控制端来做辨识资讯的指定</em>苹果公司建议使用UUID为应用生成唯一标识字符串</p><hr><h2 id="MAC-Address-Medium-Access-Control"><a href="#MAC-Address-Medium-Access-Control" class="headerlink" title="MAC Address(Medium Access Control)"></a>MAC Address(Medium Access Control)</h2><p>媒体访问控制，或称为物理地址、硬件地址，用来定义网络设备的位置。在OSI模型中，第三层网络层负责 IP地址，第二层数据链路层则负责 MAC地址。因此一个主机会有一个MAC地址，而每个网络位置会有一个专属于它的IP地址。MAC地址是网卡决定的，是固定的</p><hr><h2 id="OPEN-UDID"><a href="#OPEN-UDID" class="headerlink" title="OPEN UDID"></a>OPEN UDID</h2><p>OpenUDID是通过第一个带有OpenUDID SDK包的App生成，如果你完全删除全部带有OpenUDID SDK包的App（比如恢复系统等），那么OpenUDID会重新生成，而且和之前的值会不同，相当于新设备； 优点是没有用到MAC地址；不同设备能够获取各自唯一的识别码，保证了唯一性，可以用于以往UDID的相关用途；从代码分析OpenUDID的获取，识别码获取方便并且保存谨慎。缺点是当将设备上所有使用了OpenUDID方案的应用程序删除，且设备关机重启，xcode彻底清除并重启，重装应用程序去获取OpenUDID，此时OpenUDID变化，与之前不一样了，所有OpenUDID应用卸载后，由UIPasteboard保存的数据即被清除，重装故会重新获取新的OpenUDID。 那么当因为用户干预或者恶意程序，致使UIPasteboard数据清除，从而导致OpenUDID被删除，重装也会获取新的OpenUDID。</p><hr><h2 id="广告标识符-IDFA-identifierForldentifier"><a href="#广告标识符-IDFA-identifierForldentifier" class="headerlink" title="广告标识符(IDFA-identifierForldentifier)"></a>广告标识符(IDFA-identifierForldentifier)</h2><p>是iOS 6中另外一个新的方法，提供了一个方法advertisingIdentifier，通过调用该方法会返回一个NSUUID实例，最后可以获得一个UUID，由系统存储着的。不过即使这是由系统存储的，但是有几种情况下，会重新生成广告标示符。如果用户完全重置系统（(设置程序 -&gt; 通用 -&gt; 还原 -&gt; 还原位置与隐私) ，这个广告标示符会重新生成。另外如果用户明确的还原广告(设置程序-&gt; 通用 -&gt; 关于本机 -&gt; 广告 -&gt; 还原广告标示符) ，那么广告标示符也会重新生成。关于广告标示符的还原，有一点需要注意：如果程序在后台运行，此时用户“还原广告标示符”，然后再回到程序中，此时获取广 告标示符并不会立即获得还原后的标示符。必须要终止程序，然后再重新启动程序，才能获得还原后的广告标示符。</p><hr><h2 id="Vendor标识符-IDFV-identifierForVendor"><a href="#Vendor标识符-IDFV-identifierForVendor" class="headerlink" title="Vendor标识符(IDFV-identifierForVendor)"></a>Vendor标识符(IDFV-identifierForVendor)</h2><p>Vendor是CFBundleIdentifier（反转DNS格式）的前两部分。来自同一个运营商的应用运行在同一个设备上，此属性的值是相同的；不同的运营商应用运行在同一个设备上值不同。 经测试，只要设备上有一个运营商的app，重新安装后的identifierForVendor值不变，如果该运营商的app全部删除，重新安装后的identifierForVendor值改变。</p><hr><h2 id="调研结果"><a href="#调研结果" class="headerlink" title="调研结果"></a>调研结果</h2><p>IMEI 苹果允许的API 但不能获取,不会变化,设备唯一。</p><hr><p>UDID 曾经可以获取,单现在也成为禁止调用的API,不会变化,设备唯一。</p><hr><p>MAC 不能直接通过设备API获取,某种脑洞可以通过WIFI下路由器反馈信息来回传MAC地址,很不方便不会变化,设备唯一</p><hr><p>IDFA 广告标示符,经常容易变,每当用户针对应用程序关闭再开启一次广告追踪就会发生变化</p><hr><p>IDFV 厂商标示符,不太容易变,每当用户卸载完应用厂家旗下所有的应用程序后,再次安装,会发生变化</p><hr><p>NSUUID 苹果API接口,每次获取都变化</p><hr><p>可以确认的是，在众多可选的标识方案里，都不能保证永远不变，所以必须配合钥匙扣使用，有了钥匙扣至少保证，只要用户不刷机，无论是升级系统，还是卸载光所有的应用程序，都不会发生变化,只要有了钥匙扣的辅助，可以说随便选一个标识，只要存入钥匙圈，都能保证不变了。推荐选择了目前来看更加稳定的IDFV</p><p><a href="https://github.com/heliosneverend/HeliosKeychain" target="_blank" rel="noopener">示例代码Demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;iOS获取设备唯一标识符&quot;&gt;&lt;a href=&quot;#iOS获取设备唯一标识符&quot; class=&quot;headerlink&quot; title=&quot;iOS获取设备唯一标识符&quot;&gt;&lt;/a&gt;iOS获取设备唯一标识符&lt;/h1&gt;&lt;h2 id=&quot;UDID-Unique-Device-Identi
      
    
    </summary>
    
    
  </entry>
  
</feed>
