<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Heliso</title>
  
  <subtitle>记录平时学习到的东西</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-10T08:20:02.776Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zyf</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Swift闭包</title>
    <link href="http://yoursite.com/2018/09/10/Swift%E9%97%AD%E5%8C%85/"/>
    <id>http://yoursite.com/2018/09/10/Swift闭包/</id>
    <published>2018-09-10T07:45:01.000Z</published>
    <updated>2018-09-10T08:20:02.776Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闭包的基本概念"><a href="#闭包的基本概念" class="headerlink" title="闭包的基本概念"></a>闭包的基本概念</h2><p>闭包的就是匿名函数，类似于Objective-c或C中的block以及其他语言的lambdas。闭包可以获取闭包所在的上下文的变量和常量，并在闭包内部使用。在Swift中，全局函数和嵌套函数是特殊的闭包，有3种类型。<br>全局闭包：定义在全局，不捕获外部变量<br>局部闭包：定义在函数内部，会捕获函数里面的变量<br>匿名的闭包表达式：可以捕获上下文的变量</p><h2 id="闭包的表达式语法"><a href="#闭包的表达式语法" class="headerlink" title="闭包的表达式语法"></a>闭包的表达式语法</h2><p>swift中的闭包表达式定义如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; (parameters) -&gt; return type in</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关键字in前面的是闭包的申明部分，类似函数的申明，包括参数的申明和返回值的申明；in后面的部分是闭包的实现。比如swift自带的array的sort函数，调用sort的时候需要传一个compare的闭包进去，代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reversedNames = names.sorted(by: &#123; (s1: String, s2: String) -&gt; Bool in</span><br><span class="line">    return s1 &gt; s2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="根据上下文推测类型"><a href="#根据上下文推测类型" class="headerlink" title="根据上下文推测类型"></a>根据上下文推测类型</h3><p>上面的sort方法传入的是一个很标准的闭包表达式，在swift中，闭包表达式可以更简单，swift可以根据上下文推断出闭包表达式中参数的类型，以及返回值的类型。比如上面的sort函数，传入的闭包肯定是比较array里面的元素，所以闭包参数的类型肯定和array里面的元素类型一样（在这里是String类型），同样的，作为比较函数，返回值肯定是Bool类型。所以，参数类型和返回值类型都可以根据上下文推断出来，那么在闭包里面就可以直接省略。更简介的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames = names.sorted(by: &#123; s1, s2 in return s1 &gt; s2 &#125; )</span><br></pre></td></tr></table></figure></p><h3 id="省略return关键字"><a href="#省略return关键字" class="headerlink" title="省略return关键字"></a>省略return关键字</h3><p>当闭包的实现只有一行代码的时候，可以省略return关键字。比如在上面的代码中sorted(by:) 函数的定义明确表示需要闭包返回一个Bool类型的值，同时闭包的实现只有一行代码，显然可以判断，这一行代码肯定返回一个Bool类型的值，所以return关键字可以直接省略</p><h3 id="简写参数名"><a href="#简写参数名" class="headerlink" title="简写参数名"></a>简写参数名</h3><p>swift可以采用更简洁的方式来定义参数名，例如采用$0,$1,$2等等来引用闭包的参数，如果采用这种参数，in关键字也可以省略掉，最后闭包表达式可以非常简单，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames = names.sorted(by: &#123; $0 &gt; $1 &#125; )</span><br></pre></td></tr></table></figure></p><p>$0表示第一个参数，$1表示第二个参数。</p><h3 id="运算符函数"><a href="#运算符函数" class="headerlink" title="运算符函数"></a>运算符函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames = names.sorted(by: &gt;)</span><br></pre></td></tr></table></figure><h2 id="尾闭包"><a href="#尾闭包" class="headerlink" title="尾闭包"></a>尾闭包</h2><p>例如有一个函数：这个函数的最后一个参数是一个闭包，并且，这个闭包表达式很长。如果按照正常的方式来调用这个函数的话，需要在参数里指明这个函数的参数名，然后后面跟着一个闭包表达式。比如下面这种函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func someFunctionThatTakesAClosure(closure: () -&gt; Void) &#123;</span><br><span class="line">    // function body goes here</span><br><span class="line">&#125;</span><br><span class="line">// Here&apos;s how you call this function without using a trailing closure:</span><br><span class="line">//正常使用该函数</span><br><span class="line">someFunctionThatTakesAClosure(closure: &#123;</span><br><span class="line">    // closure&apos;s body goes here</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// Here&apos;s how you call this function with a trailing closure instead:</span><br><span class="line">//使用尾随闭包</span><br><span class="line">someFunctionThatTakesAClosure() &#123;</span><br><span class="line">    // trailing closure&apos;s body goes here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Swift的Array的sort函数也可以采用尾闭包的方式来调用，比如上面对字符串数组排序的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames = names.sorted() &#123; $0 &gt; $1 &#125;</span><br></pre></td></tr></table></figure></p><p>如果一个函数只有一个参数，并且这个参数是一个闭包，那么在使用这个函数的时候可以省略括号，比如上面的sorted函数可以写成这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames = names.sorted &#123; $0 &gt; $1 &#125;</span><br></pre></td></tr></table></figure></p><h2 id="逃逸闭包"><a href="#逃逸闭包" class="headerlink" title="逃逸闭包"></a>逃逸闭包</h2><p>当一个传入函数的闭包在函数执行结束之后才会被调用，这样的闭包就叫做逃逸闭包。如果一个函数的参数有一个逃逸闭包，可以在参数前加@escaping关键字来修饰。<br>一个闭包是逃逸必要的条件是这个闭包需要存储在函数外部。举个例子，很多异步操作的函数往往会传入一个complete handler作为异步操作完成后的回调。当这个异步函数开始执行的时候，会开启一个异步操作，然后这个函数就直接结束了，此时，传入的闭包还没有被执行，实际上这个回调需要在异步操作完成后才会被执行。这种情况下这个回调的闭包需要定义成逃逸闭包，因为它在函数调用结束之后才会被执行。比如下面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var completionHandlers: [() -&gt; Void] = []</span><br><span class="line">func someFunctionWithEscapingClosure(completionHandler: @escaping () -&gt; Void) &#123;</span><br><span class="line">    completionHandlers.append(completionHandler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>someFunctionWithEscapingClosure以一个completionHandler作为参数，这个参数会被保存在函数外部的completionHandlers数组中，这时这个闭包是一个逃逸闭包，所以需要添加@escaping关键字去修饰，否则会有编译错误。<br>逃逸闭包如果需要使用对象的变量或常量的时候，必须显示指明self，如果是普通的闭包，可以直接使用对象的变量或常量。比如下面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var completionHandlers: [() -&gt; Void] = []</span><br><span class="line">func someFunctionWithEscapingClosure(completionHandler: @escaping () -&gt; Void) &#123;</span><br><span class="line">    completionHandlers.append(completionHandler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func someFunctionWithNonescapingClosure(closure: () -&gt; Void) &#123;</span><br><span class="line">    closure()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SomeClass &#123;</span><br><span class="line">    var x = 10</span><br><span class="line">    func doSomething() &#123;</span><br><span class="line">    someFunctionWithEscapingClosure &#123; self.x = 100 &#125;</span><br><span class="line">    someFunctionWithNonescapingClosure &#123; x = 200 &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let instance = SomeClass()</span><br><span class="line">instance.doSomething()</span><br><span class="line">print(instance.x)</span><br><span class="line">// 输出 &quot;200&quot;</span><br><span class="line"></span><br><span class="line">completionHandlers.first?()</span><br><span class="line">print(instance.x)</span><br><span class="line">// 输出 &quot;100&quot;</span><br></pre></td></tr></table></figure></p><p>在这个例子中，第一个print输出200，因为当调用doSomethig的时候，someFunctionWithNonescapingClosure会直接调用闭包{x = 200},此时instance.x变成200，当completionHandlers.first?()之后，someFunctionWithEscapingClosure传入的闭包才会真正执行，此时instance.x变成100.可以看到，逃逸闭包必须显示指明self，而普通的闭包可以直接使用x。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闭包的基本概念&quot;&gt;&lt;a href=&quot;#闭包的基本概念&quot; class=&quot;headerlink&quot; title=&quot;闭包的基本概念&quot;&gt;&lt;/a&gt;闭包的基本概念&lt;/h2&gt;&lt;p&gt;闭包的就是匿名函数，类似于Objective-c或C中的block以及其他语言的lambdas。闭包
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>7日NodeJS神功</title>
    <link href="http://yoursite.com/2018/09/10/7%E6%97%A5NodeJS%E7%A5%9E%E5%8A%9F/"/>
    <id>http://yoursite.com/2018/09/10/7日NodeJS神功/</id>
    <published>2018-09-10T02:40:09.000Z</published>
    <updated>2018-09-10T02:46:38.432Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是NodeJS"><a href="#什么是NodeJS" class="headerlink" title="什么是NodeJS"></a>什么是NodeJS</h2><p>JS是一种脚本语言,脚本语言需要解析器才能运行,对于卸载HTML的JS来说,浏览器就充当的一个解析器的角色,对于独立运行的JS来说NodeJS就是一个解析器</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是NodeJS&quot;&gt;&lt;a href=&quot;#什么是NodeJS&quot; class=&quot;headerlink&quot; title=&quot;什么是NodeJS&quot;&gt;&lt;/a&gt;什么是NodeJS&lt;/h2&gt;&lt;p&gt;JS是一种脚本语言,脚本语言需要解析器才能运行,对于卸载HTML的JS来说,浏览器就
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>理解this和对象原型</title>
    <link href="http://yoursite.com/2018/09/07/%E7%90%86%E8%A7%A3this%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/09/07/理解this和对象原型/</id>
    <published>2018-09-07T03:13:27.000Z</published>
    <updated>2018-09-07T03:23:04.161Z</updated>
    
    <content type="html"><![CDATA[<h2 id="this-解析"><a href="#this-解析" class="headerlink" title="this 解析"></a>this 解析</h2><p><img src="this.png" alt=""><br>如果要判断一个运行中函数的 this 绑定,就需要找到这个函数的直接调用位置。找到之后 就可以顺序应用下面这四条规则来判断 this 的绑定对象。<br>1 由 new 调用?绑定到新创建的对象。<br>2 由 call 或者 apply (或者 bind )调用?绑定到指定的对象。<br>3 由上下文对象调用?绑定到那个上下文对象。<br>4 默认:在严格模式下绑定到 undefined ,否则绑定到全局对象。<br>一定要注意,有些调用可能在无意中使用默认绑定规则。如果想“更安全”地忽略 this 绑 定,你可以使用一个 DMZ 对象,比如 ø = Object.create(null) ,以保护全局对象。ES6中的箭头函数并不会使用四条标准的绑定规则, 而是根据当前的词法作用域来决定 this ,具体来说,箭头函数会继承外层函数调用的 this 绑定(无论 this 绑定到什么)。这 其实和 ES6 之前代码中的 self = this 机制一样。</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p><img src="对象.png" alt=""><br><img src="对象的内容.png" alt=""><br>JavaScript 中的对象有字面形式(比如 var a = { .. } )和构造形式(比如 var a = new Array(..) )。字面形式更常用,不过有时候构造形式可以提供更多选项。<br>许多人都以为“JavaScript 中万物都是对象”,这是错误的。对象是 6 个(或者是 7 个,取 决于你的观点)基础类型之一。对象有包括 function 在内的子类型,不同子类型具有不同 的行为,比如内部标签 [object Array] 表示这是对象的子类型数组。<br>对象就是键 / 值对的集合。可以通过 .propName 或者 [“propName”] 语法来获取属性值。访 问属性时, 引擎实际上会调用内部的默认 [[Get]] 操作(在设置属性值时是 [[Put]] ), [[Get]] 操作会检查对象本身是否包含这个属性,如果没找到的话还会查找 [[Prototype]] 链(参见第 5 章)。<br>属性的特性可以通过属性描述符来控制,比如 writable 和 configurable 。此外,可以使用 Object.preventExtensions(..) 、 Object.seal(..) 和 Object.freeze(..) 来设置对象(及其 属性)的不可变性级别。<br>属性不一定包含值——它们可能是具备 getter/setter 的“访问描述符”。此外,属性可以是 可枚举或者不可枚举的,这决定了它们是否会出现在 for..in 循环中。<br>你可以使用 ES6 的 for..of 语法来遍历数据结构(数组、对象, 等等)中的值, for..of 会寻找内置或者自定义的 @@iterator 对象并调用它的 next() 方法来遍历数据值。</p><h2 id="混合对象类"><a href="#混合对象类" class="headerlink" title="混合对象类"></a>混合对象类</h2><p><img src="混合对象类.png" alt=""><br>类是一种设计模式。 许多语言提供了对于面向类软件设计的原生语法。 JavaScript 也有类 似的语法,但是和其他语言中的类完全不同。<br>类意味着复制。<br>传统的类被实例化时,它的行为会被复制到实例中。类被继承时,行为也会被复制到子类 中。<br>多态(在继承链的不同层次名称相同但是功能不同的函数)看起来似乎是从子类引用父 类,但是本质上引用的其实是复制的结果。<br>JavaScript 并不会(像类那样)自动创建对象的副本。<br>混入模式(无论显式还是隐式)可以用来模拟类的复制行为,但是通常会产生丑陋并且脆 弱的语法,比如显式伪多态( OtherObj.methodName.call(this, …) ),这会让代码更加难 懂并且难以维护。<br>此外, 显式混入实际上无法完全模拟类的复制行为, 因为对象(和函数!别忘了函数也 是对象)只能复制引用, 无法复制被引用的对象或者函数本身。 忽视这一点会导致许多 问题。<br>总地来说,在 JavaScript 中模拟类是得不偿失的,虽然能解决当前的问题,但是可能会埋下更多的隐患。</p><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p><img src="原型1.png" alt=""><br><img src="原型2.png" alt=""><br>如果要访问对象中并不存在的一个属性, [[Get]] 操作(参见第 3 章)就会查找对象内部 [[Prototype]] 关联的对象。这个关联关系实际上定义了一条“原型链”(有点像嵌套的作用域链),在查找属性时会对它进行遍历。<br>所有普通对象都有内置的 Object.prototype ,指向原型链的顶端(比如说全局作用域),如 果在原型链中找不到指定的属性就会停止。 toString() 、 valueOf() 和其他一些通用的功能 都存在于 Object.prototype 对象上,因此语言中所有的对象都可以使用它们。<br>关联两个对象最常用的方法是使用 new 关键词进行函数调用, 在调用的 章)中会创建一个关联其他对象的新对象。4个步骤(第2章)中会创建一个关联其他对象的新对象。<br>使用 new 调用函数时会把新对象的 .prototype 属性关联到“其他对象”。带 new 的函数调用 通常被称为“构造函数调用”,尽管它们实际上和传统面向类语言中的 类构造函数 不一样。<br>JavaScript 是 中的机制有一个核心区别, 那就是不会进行复制, 对象之间是通过内部的<br>虽然这些 机制和传统面向类语言中的“类初始化”和“类继承”很相似, 但是  javascript 机制和传统面向对象类语言中的“类初始化”和“类继承”很相似但是 javascript 中的机制有一个核心区别，就是不会进行复制，对象之间是通过内部的 [[Prototype]] 链关联的。<br>出于各种原因,以“继承”结尾的术语(包括“原型继承”)和其他面向对象的术语都无 法帮助你理解 JavaScript 的 真实 机制(不仅仅是限制我们的思维模式)。<br>相比之下,“委托”是一个更合适的术语,因为对象之间的关系不是 复制 而是委托。</p><h2 id="行为委托"><a href="#行为委托" class="headerlink" title="行为委托"></a>行为委托</h2><p> <img src="行为委托.png" alt=""><br> 在软件架构中你可以 选择是否 使用类和继承设计模式。大多数开发者理所当然地认为类是 唯一(合适)的代码组织方式,但是本章中我们看到了另一种更少见但是更强大的设计模式: 行为委托 。<br> 行为委托认为对象之间是兄弟关系, 互相委托, 而不是父类和子类的关系。 JavaScript 的 [[Prototype]] 机制本质上就是行为委托机制。也就是说,我们可以选择在 JavaScript 中努 力实现类机制(参见第 4 和第 5 章),也可以拥抱更自然的 [[Prototype]] 委托机制。<br> 当你只用对象来设计代码时,不仅可以让语法更加简洁,而且可以让代码结构更加清晰。<br> 对象关联(对象之前互相关联)是一种编码风格,它倡导的是直接创建和关联对象,不把 它们抽象成类。对象关联可以用基于 [[Prototype]] 的行为委托非常自然地实现。</p><p> <a href="https://juejin.im/post/5b0cafad51882515624dc6d2" target="_blank" rel="noopener">From</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;this-解析&quot;&gt;&lt;a href=&quot;#this-解析&quot; class=&quot;headerlink&quot; title=&quot;this 解析&quot;&gt;&lt;/a&gt;this 解析&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;this.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;如果要判断一个运行中函数的 this 
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>对JavaScript中作用域和闭包的理解</title>
    <link href="http://yoursite.com/2018/09/07/%E5%AF%B9JavaScript%E4%B8%AD%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/09/07/对JavaScript中作用域和闭包的理解/</id>
    <published>2018-09-07T02:50:47.000Z</published>
    <updated>2018-09-07T03:12:35.215Z</updated>
    
    <content type="html"><![CDATA[<h2 id="作用域是什么"><a href="#作用域是什么" class="headerlink" title="作用域是什么"></a>作用域是什么</h2><p>看一下思维导图<br><img src="作用域.png" alt=""><br>作用域是一套规则,用于确定在何处以及如何查找变量(标识符)。如果查找的目的是对 变量进行赋值,那么就会使用 LHS 查询;如果目的是获取变量的值,就会使用 RHS 查询。赋值操作符会导致 LHS 查询。 的赋值操作。 =操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。<br>JavaScript 引擎首先会在代码执行前对其进行编译,在这个过程中,像 var a = 2 这样的声 明会被分解成两个独立的步骤：<br>一: 首先, var a 在其作用域中声明新变量。这会在最开始的阶段,也就是代码执行前进行。<br>二: 接下来, a = 2 会查询(LHS 查询)变量 a 并对其进行赋值。<br>LHS 和 RHS 查询都会在当前执行作用域中开始,如果有需要(也就是说它们没有找到所 需的标识符),就会向上级作用域继续查找目标标识符,这样每次上升一级作用域(一层 楼),最后抵达全局作用域(顶层),无论找到或没找到都将停止。<br>不成功的RHS引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式地创建一个全局变量(非严格模式下),该变量使用 LHS 引用的目标作为标识符,或者抛 出 ReferenceError 异常(严格模式下)。</p><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p><img src="词法作用域.png" alt=""><br>词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段 基本能够知道全部标识符在哪里以及是如何声明的,从而能够预测在执行过程中如何对它 们进行查找。<br>JavaScript 中有两个机制可以“欺骗”词法作用域: eval(..) 和 with 。 前者可以对一段包 含一个或多个声明的“代码”字符串进行演算,并借此来修改已经存在的词法作用域(在 运行时)。后者本质上是通过将一个对象的引用 当作 作用域来处理,将对象的属性当作作 用域中的标识符来处理,从而创建了一个新的词法作用域(同样是在运行时)。<br>这两个机制的副作用是引擎无法在编译时对作用域查找进行优化,因为引擎只能谨慎地认 为这样的优化是无效的。使用这其中任何一个机制都 将 导致代码运行变慢。 不要使用它们。</p><h3 id="函数作用域和块作用域"><a href="#函数作用域和块作用域" class="headerlink" title="函数作用域和块作用域"></a>函数作用域和块作用域</h3><p><img src="函数作用域.png" alt=""><br>函数是 JavaScript 中最常见的作用域单元。本质上,声明在一个函数内部的变量或函数会 在所处的作用域中“隐藏”起来,这是有意为之的良好软件的设计原则。<br>但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域, 也可以属于某个代码块(通常指 { .. } 内部)。<br>从 ES3 开始, try/catch 结构在 catch 分句中具有块作用域。在 ES6 中引入了 let 关键字( var 关键字的表亲), 用来在任意代码块中声明变量。 if(..) { let a = 2; } 会声明一个劫持了 if 的 { .. } 块的变量,并且将变量添加到这个块 中。<br>有些人认为块作用域不应该完全作为函数作用域的替代方案。两种功能应该同时存在,开 发者可以并且也应该根据需要选择使用何种作用域,创造可读、可维护的优良代码。</p><h3 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h3><p><img src="提升.png" alt=""><br>我们习惯将 var a = 2; 看作一个声明,而实际上 JavaScript 引擎并不这么认为。它将 var a 和 a = 2 当作两个单独的声明,第一个是编译阶段的任务,而第二个则是执行阶段的任务。<br>这意味着无论作用域中的声明出现在什么地方,都将在代码本身被执行前 首先 进行处理。 可以将这个过程形象地想象成所有的声明(变量和函数)都会被“移动”到各自作用域的最顶端,这个过程被称为提升。<br>声明本身会被提升,而包括函数表达式的赋值在内的赋值操作并不会提升。<br>要注意避免重复声明,特别是当普通的 var 声明和函数声明混合在一起的时候,否则会引 起很多危险的问题!</p><h3 id="作用域闭包"><a href="#作用域闭包" class="headerlink" title="作用域闭包"></a>作用域闭包</h3><p><img src="作用域闭包.png" alt=""><br>闭包就好像从 JavaScript 中分离出来的一个充满神秘色彩的未开化世界,只有最勇敢的人 才能够到达那里。但实际上它只是一个标准,显然就是关于如何在函数作为值按需传递的 词法环境中书写代码的。<br>当函数可以记住并访问所在的词法作用域,即使函数是在当前词法作用域之外执行,这时 就产生了闭包。<br>如果没能认出闭包,也不了解它的工作原理,在使用它的过程中就很容易犯错,比如在循 环中。但同时闭包也是一个非常强大的工具,可以用多种形式来实现 模块 等模式。模块有两个主要特征:<br>(1)为创建内部作用域而调用了一个包装函数;<br>(2)包装函数的返回 值必须至少包括一个对内部函数的引用,这样就会创建涵盖整个包装函数内部作用域的闭 包。<br>现在我们会发现代码中到处都有闭包存在,并且我们能够识别闭包然后用它来做一些有用 的事!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;作用域是什么&quot;&gt;&lt;a href=&quot;#作用域是什么&quot; class=&quot;headerlink&quot; title=&quot;作用域是什么&quot;&gt;&lt;/a&gt;作用域是什么&lt;/h2&gt;&lt;p&gt;看一下思维导图&lt;br&gt;&lt;img src=&quot;作用域.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;作用域是一套规则,用于确定
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>解决网络请求的依赖关系</title>
    <link href="http://yoursite.com/2018/09/05/%E8%A7%A3%E5%86%B3%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/"/>
    <id>http://yoursite.com/2018/09/05/解决网络请求的依赖关系/</id>
    <published>2018-09-05T09:22:25.000Z</published>
    <updated>2018-09-05T10:24:10.879Z</updated>
    
    <content type="html"><![CDATA[<h2 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h2><p>在开发中 当一个接口的请求依赖于另外一个接口返回的数据</p><h2 id="几种解决思路"><a href="#几种解决思路" class="headerlink" title="几种解决思路"></a>几种解决思路</h2><h3 id="使用NSOperation的dependency和优先级"><a href="#使用NSOperation的dependency和优先级" class="headerlink" title="使用NSOperation的dependency和优先级"></a>使用NSOperation的dependency和优先级</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[operationB addDependency:operationA];</span><br></pre></td></tr></table></figure><p>在异步请求的时候不适用,异步请求时不是立即返回不能保证回调是再开启下一个网络请求</p><h3 id="在A的网络请求的响应回调中进行下一次的网络请求"><a href="#在A的网络请求的响应回调中进行下一次的网络请求" class="headerlink" title="在A的网络请求的响应回调中进行下一次的网络请求"></a>在A的网络请求的响应回调中进行下一次的网络请求</h3><p>可能拿不到回调无法执行block的代码</p><h3 id="组队列-dispatch-group"><a href="#组队列-dispatch-group" class="headerlink" title="组队列 dispatch_group"></a>组队列 dispatch_group</h3><p>建一个全局的queue 以及一个group,然后在group queue里面一次添加block 最后调用dispatch_group_notifiy添加block,当前面的block执行完毕就开始执行最后的block</p><h3 id="线程同步-–任务阻塞-dispatch-barrier"><a href="#线程同步-–任务阻塞-dispatch-barrier" class="headerlink" title="线程同步 –任务阻塞 dispatch_barrier"></a>线程同步 –任务阻塞 dispatch_barrier</h3><p>通过dispatch_barrier_async添加的操作会暂时阻塞当前的队列,等待前面的并发操作都执行完毕后在执行后面的操作</p><h3 id="信号量-dispatch-semaphore"><a href="#信号量-dispatch-semaphore" class="headerlink" title="信号量 dispatch_semaphore"></a>信号量 dispatch_semaphore</h3><p>在异步开启任务 1 和任务 2 之前，初始化一个信号量并设置为 0，然后在任务 1 的 block 中写好请求操作，操作执行完后对前面的信号量加 1，在任务 2 的 block 中，需要在开始请求之前加上等待信号量的操作。这样一来，只有任务 1 中的请求执行完后，任务 2 等到了信号量加 1 才接着执行它的请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        NSLog(@&quot;任务一开始&quot;);</span><br><span class="line">        [NSThread sleepForTimeInterval:2];</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        NSLog(@&quot;任务二开始&quot;);</span><br><span class="line">        [NSThread sleepForTimeInterval:2];</span><br><span class="line">        NSLog(@&quot;任务二结束&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    [NSThread sleepForTimeInterval:10];</span><br><span class="line">    NSLog(@&quot;结束&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="异步请求.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;业务场景&quot;&gt;&lt;a href=&quot;#业务场景&quot; class=&quot;headerlink&quot; title=&quot;业务场景&quot;&gt;&lt;/a&gt;业务场景&lt;/h2&gt;&lt;p&gt;在开发中 当一个接口的请求依赖于另外一个接口返回的数据&lt;/p&gt;
&lt;h2 id=&quot;几种解决思路&quot;&gt;&lt;a href=&quot;#几种解决
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>使用runtime给VC添加navigationBar隐藏属性</title>
    <link href="http://yoursite.com/2018/09/05/%E4%BD%BF%E7%94%A8runtime%E7%BB%99VC%E6%B7%BB%E5%8A%A0navigationBar%E9%9A%90%E8%97%8F%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2018/09/05/使用runtime给VC添加navigationBar隐藏属性/</id>
    <published>2018-09-05T08:39:51.000Z</published>
    <updated>2018-09-05T09:12:02.793Z</updated>
    
    <content type="html"><![CDATA[<h2 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h2><p>在开发中 在一些页面我们要隐藏导航栏,一般在ViewWillApper方法和ViewDidDisappear中去设置navigationBar的hidden属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewWillAppear:(BOOL)animated &#123;</span><br><span class="line">    [super viewWillAppear:animated];</span><br><span class="line">    self.navigationController.navigationBarHidden = YES;</span><br><span class="line">&#125;</span><br><span class="line">- (void)viewDidDisappear:(BOOL)animated &#123;</span><br><span class="line">    [super viewDidDisappear:animated];</span><br><span class="line">    self.navigationController.navigationBarHidden = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="更加轻量级的解决方案"><a href="#更加轻量级的解决方案" class="headerlink" title="更加轻量级的解决方案"></a>更加轻量级的解决方案</h2><p>添加一个viewController的分类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;UIViewController+hiddenNavigationBar.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">static BOOL didInitializaed = NO;</span><br><span class="line">static UInt8 hideNavigationBarAssociationKey = 0;</span><br><span class="line"></span><br><span class="line">@implementation UIViewController (hiddenNavigationBar)</span><br><span class="line"></span><br><span class="line">static void replaceInteractiveMethod() &#123;</span><br><span class="line">    class_getMethodImplementation([UIViewController class], @selector(MY_intereactiveViewWillAppear:));</span><br><span class="line">    method_exchangeImplementations(class_getInstanceMethod([UIViewController class], @selector(viewWillAppear:)), class_getInstanceMethod([UIViewController class], @selector(MY_intereactiveViewWillAppear:)));</span><br><span class="line">&#125;</span><br><span class="line">#pragma mark -Override Class Method</span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    if (!didInitializaed) &#123;</span><br><span class="line">        replaceInteractiveMethod();</span><br><span class="line">        didInitializaed = YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (void)MY_intereactiveViewWillAppear:(BOOL)animated &#123;</span><br><span class="line">    [self MY_intereactiveViewWillAppear:animated];</span><br><span class="line">    [self setHideNavigationBar:self.hideNavigationBar];</span><br><span class="line">&#125;</span><br><span class="line">- (void)setHiddenNavigationBar:(BOOL)hiddenNavigationBar &#123;</span><br><span class="line">    NSNumber *barHidden = [NSNumber numberWithBool:hiddenNavigationBar];</span><br><span class="line">    objc_setAssociatedObject(self, &amp;hideNavigationBarAssociationKey, barHidden,     OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">&#125;</span><br><span class="line">#pragma getter and setter</span><br><span class="line">- (void)setHideNavigationBar:(BOOL)hideNavigationBar &#123;</span><br><span class="line">    NSNumber *barHidden = [NSNumber numberWithBool:hideNavigationBar];</span><br><span class="line">    objc_setAssociatedObject(self, &amp;hideNavigationBarAssociationKey, barHidden, OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)hideNavigationBar &#123;</span><br><span class="line">    NSNumber *barHidden = objc_getAssociatedObject(self, &amp;hideNavigationBarAssociationKey);</span><br><span class="line">    return [barHidden boolValue];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.hideNavigationBar = YES;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;业务场景&quot;&gt;&lt;a href=&quot;#业务场景&quot; class=&quot;headerlink&quot; title=&quot;业务场景&quot;&gt;&lt;/a&gt;业务场景&lt;/h2&gt;&lt;p&gt;在开发中 在一些页面我们要隐藏导航栏,一般在ViewWillApper方法和ViewDidDisappear中去设置navi
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>在tableView显示不同的背景色</title>
    <link href="http://yoursite.com/2018/09/05/%E5%9C%A8tableView%E6%98%BE%E7%A4%BA%E4%B8%8D%E5%90%8C%E7%9A%84%E8%83%8C%E6%99%AF%E8%89%B2/"/>
    <id>http://yoursite.com/2018/09/05/在tableView显示不同的背景色/</id>
    <published>2018-09-05T08:20:18.000Z</published>
    <updated>2018-09-05T08:35:39.854Z</updated>
    
    <content type="html"><![CDATA[<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>UITableView或UICollectionView和UIScrollView在添加下拉刷新的时候,业务需求在refreshControl显示特定的颜色 不同于UITableView.backgroundColor</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><h3 id="croll在UITableView图层下面添加一个固定高度的View去填充你想要的颜色"><a href="#croll在UITableView图层下面添加一个固定高度的View去填充你想要的颜色" class="headerlink" title="croll在UITableView图层下面添加一个固定高度的View去填充你想要的颜色"></a>croll在UITableView图层下面添加一个固定高度的View去填充你想要的颜色</h3><p>这个方案在数据较少的时候会出现问题</p><h3 id="在UITableView-图层下面添加一个View-在-void-scrollViewDidScroll-UIScrollView-scrollView代理方法里面监听scrollView-contentOffSet-y去动态的改变View的高度"><a href="#在UITableView-图层下面添加一个View-在-void-scrollViewDidScroll-UIScrollView-scrollView代理方法里面监听scrollView-contentOffSet-y去动态的改变View的高度" class="headerlink" title="在UITableView 图层下面添加一个View 在- (void)scrollViewDidScroll:(UIScrollView *)scrollView代理方法里面监听scrollView.contentOffSet.y去动态的改变View的高度"></a>在UITableView 图层下面添加一个View 在- (void)scrollViewDidScroll:(UIScrollView *)scrollView代理方法里面监听scrollView.contentOffSet.y去动态的改变View的高度</h3><p>这种方法在松手的一瞬间出出现短暂的颜色问题 同时也会消耗额外的CPU性能 不是最优解</p><h3 id="在TableView上添加一个子视图-让改视图超出tableView的边界"><a href="#在TableView上添加一个子视图-让改视图超出tableView的边界" class="headerlink" title="在TableView上添加一个子视图,让改视图超出tableView的边界"></a>在TableView上添加一个子视图,让改视图超出tableView的边界</h3><h4 id="OC"><a href="#OC" class="headerlink" title="OC"></a>OC</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CGRect frame = self.tableView.bounds;</span><br><span class="line">frame.origin.y = -frame.size.height;</span><br><span class="line">UIView* grayView = [[UIView alloc] initWithFrame:frame];</span><br><span class="line">grayView.backgroundColor = [UIColor grayColor];</span><br><span class="line">[self.tableView addSubview:grayView];</span><br></pre></td></tr></table></figure><h4 id="swift"><a href="#swift" class="headerlink" title="swift"></a>swift</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">extension UITableView &#123;</span><br><span class="line">    func addTopBounceAreaView(color: UIColor = .white) &#123;</span><br><span class="line">        var frame = self.bounds</span><br><span class="line">        frame.origin.y = -frame.size.height</span><br><span class="line">        let view = UIView(frame: frame)</span><br><span class="line">        view.backgroundColor = color</span><br><span class="line">        self.addSubview(view)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://stackoverflow.com/questions/1114587/different-background-colors-for-the-top-and-bottom-of-a-uitableview/51077378#51077378" target="_blank" rel="noopener">参考地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;应用场景&quot;&gt;&lt;a href=&quot;#应用场景&quot; class=&quot;headerlink&quot; title=&quot;应用场景&quot;&gt;&lt;/a&gt;应用场景&lt;/h2&gt;&lt;p&gt;UITableView或UICollectionView和UIScrollView在添加下拉刷新的时候,业务需求在refre
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Shell流程控制</title>
    <link href="http://yoursite.com/2018/09/03/Shell%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/2018/09/03/Shell流程控制/</id>
    <published>2018-09-03T09:29:25.957Z</published>
    <updated>2018-09-03T10:21:15.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">以if-else为例:</span><br><span class="line">a=10</span><br><span class="line">b=12</span><br><span class="line">if [$a == $b]</span><br><span class="line">then</span><br><span class="line">...</span><br><span class="line">else </span><br><span class="line">...</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h2 id="if-elseif-else语句"><a href="#if-elseif-else语句" class="headerlink" title="if - elseif -else语句"></a>if - elseif -else语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if [$a == $b]</span><br><span class="line">then</span><br><span class="line">...</span><br><span class="line">elif [条件]</span><br><span class="line">then</span><br><span class="line">...</span><br><span class="line">else</span><br><span class="line">...</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h2 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a>for循环语句</h2><h3 id="读取数组"><a href="#读取数组" class="headerlink" title="读取数组"></a>读取数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for name in &quot;Mike&quot; &quot;John&quot; &quot;Andy&quot;</span><br><span class="line">do </span><br><span class="line">echo $name</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="从变量读取列表"><a href="#从变量读取列表" class="headerlink" title="从变量读取列表"></a>从变量读取列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#⚠️此处需要使用转义符号来输出&apos;</span><br><span class="line">for name in I don\&apos;t know</span><br><span class="line">do </span><br><span class="line">echo $name</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="读取目录文件"><a href="#读取目录文件" class="headerlink" title="读取目录文件"></a>读取目录文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#⚠️此处需要使用通配符*</span><br><span class="line">fileUrl=&quot;/users/yzy/desktop/*&quot;</span><br><span class="line">for file in fileUrl</span><br><span class="line">do </span><br><span class="line">echo $file</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="条件循环"><a href="#条件循环" class="headerlink" title="条件循环"></a>条件循环</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for ((a=1 ; a &lt; 5; a++))</span><br><span class="line">do </span><br><span class="line">echo %a</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for ((a=1 ; a &lt; 5; a++))</span><br><span class="line">do </span><br><span class="line">for ((b=1; b &lt; 5; b++))</span><br><span class="line">do </span><br><span class="line">...</span><br><span class="line">done</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句"></a>while循环语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while (($a &lt; 10))</span><br><span class="line">do</span><br><span class="line">...</span><br><span class="line">done</span><br><span class="line">while无限循环：</span><br><span class="line">while true或者while :</span><br></pre></td></tr></table></figure><h2 id="switch条件选择语句"><a href="#switch条件选择语句" class="headerlink" title="switch条件选择语句"></a>switch条件选择语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">number=1</span><br><span class="line">case $number in</span><br><span class="line">1) echo &quot;等于1&quot;</span><br><span class="line">;;</span><br><span class="line">2) echo &quot;等于2&quot;</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><h2 id="until循环"><a href="#until循环" class="headerlink" title="until循环"></a>until循环</h2><p>跟while相反，当条件为false时候进入循环<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until 条件</span><br><span class="line">do </span><br><span class="line">代码</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><h2 id="break退出循环"><a href="#break退出循环" class="headerlink" title="break退出循环"></a>break退出循环</h2><p>如果是循环嵌套的话，break写在内部循环中，当执行时只会退出内部循环。</p><p>⚠️如果想一下子退出多层循环，可：<br>break 2 在break后接层数</p><h2 id="continue结束当前循环"><a href="#continue结束当前循环" class="headerlink" title="continue结束当前循环"></a>continue结束当前循环</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;if语句&quot;&gt;&lt;a href=&quot;#if语句&quot; class=&quot;headerlink&quot; title=&quot;if语句&quot;&gt;&lt;/a&gt;if语句&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
      <category term="Shell" scheme="http://yoursite.com/categories/Shell/"/>
    
    
      <category term="Shell" scheme="http://yoursite.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>黑魔法Clang Attribute</title>
    <link href="http://yoursite.com/2018/09/03/%E9%BB%91%E9%AD%94%E6%B3%95Clang%20Attribute/"/>
    <id>http://yoursite.com/2018/09/03/黑魔法Clang Attribute/</id>
    <published>2018-09-03T03:07:16.000Z</published>
    <updated>2018-09-03T07:43:10.384Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Clang-Attribute-说明"><a href="#Clang-Attribute-说明" class="headerlink" title="Clang Attribute 说明"></a>Clang Attribute 说明</h1><p>Clang Attribute 是Clang提供的一种源码注解,一般以<strong>attribute</strong>(xxx) 的形式出现在代码中</p><h1 id="constructor-destructor"><a href="#constructor-destructor" class="headerlink" title="constructor / destructor"></a>constructor / destructor</h1><p>构造器和析构器，加上这两个属性的函数会在分别在可执行文件（或 shared library）load 和 unload 时被调用，可以理解为在 main() 函数调用前和 return 后执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((constructor))</span><br><span class="line">static void beforeMain(void) &#123;</span><br><span class="line">NSLog(@&quot;beforeMain&quot;);</span><br><span class="line">&#125;</span><br><span class="line">__attribute__((destructor))</span><br><span class="line">static void afterMain(void) &#123;</span><br><span class="line">NSLog(@&quot;afterMain&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">NSLog(@&quot;main&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Console:</span><br><span class="line">// &quot;beforeMain&quot; -&gt; &quot;main&quot; -&gt; &quot;afterMain&quot;</span><br></pre></td></tr></table></figure></p><p>constructor 和 +load 都是在 main 函数执行前调用，但 +load 比 constructor 更加早一丢丢，因为 dyld（动态链接器，程序的最初起点）在加载 image（可以理解成 Mach-O 文件）时会先通知 objc runtime 去加载其中所有的类，每加载一个类时，它的 +load 随之调用，全部加载完成后，dyld 才会调用这个 image 中所有的 constructor 方法。<br>所以 constructor 是一个干坏事的绝佳时机：<br>所有 Class 都已经加载完成<br>main 函数还未执行<br>无需像 +load 还得挂载在一个 Class 中<br>FDStackView 的 FDStackViewPatchEntry 方法便是使用的这个时机来实现偷天换日的伎俩。<br>PS：若有多个 constructor 且想控制优先级的话，可以写成 <strong>attribute</strong>((constructor(101)))，里面的数字越小优先级越高，1 ~ 100 为系统保留。</p><h1 id="enable-if"><a href="#enable-if" class="headerlink" title="enable_if"></a>enable_if</h1><p>这个属性只能用在 C 函数上，可以用来实现参数的静态检查：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static void printValidAge(int age)</span><br><span class="line">__attribute__((enable_if(age &gt; 0 &amp;&amp; age &lt; 120, &quot;你火星人？&quot;))) &#123;</span><br><span class="line">printf(&quot;%d&quot;, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它表示调用这个函数时必须满足 age &gt; 0 &amp;&amp; age &lt; 120 才被允许，于是乎：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">printValidAge(26); // √</span><br><span class="line">printValidAge(150); // &lt;--- Compile Error</span><br><span class="line">printValidAge(-1); // &lt;--- Compile Error</span><br></pre></td></tr></table></figure></p><h1 id="cleanup"><a href="#cleanup" class="headerlink" title="cleanup"></a>cleanup</h1><p>声明到一个变量上，当这个变量作用域结束时，调用指定的一个函数，Reactive Cocoa 用这个特性实现了神奇的 @onExit</p><h1 id="overloadable"><a href="#overloadable" class="headerlink" title="overloadable"></a>overloadable</h1><p>用于 C 函数，可以定义若干个函数名相同，但参数不同的方法，调用时编译器会自动根据参数选择函数原型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((overloadable)) void logAnything(id obj) &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, obj);</span><br><span class="line">&#125;</span><br><span class="line">__attribute__((overloadable)) void logAnything(int number) &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, @(number));</span><br><span class="line">&#125;</span><br><span class="line">__attribute__((overloadable)) void logAnything(CGRect rect) &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, NSStringFromCGRect(rect));</span><br><span class="line">&#125;</span><br><span class="line">// Tests</span><br><span class="line">logAnything(@[@&quot;1&quot;, @&quot;2&quot;]);</span><br><span class="line">logAnything(233);</span><br><span class="line">logAnything(CGRectMake(1, 2, 3, 4));</span><br></pre></td></tr></table></figure></p><h1 id="objc-subclassing-restricted"><a href="#objc-subclassing-restricted" class="headerlink" title="objc_subclassing_restricted"></a>objc_subclassing_restricted</h1><p>使用这个属性可以定义一个不可被继承的类,只需在@interface前面加上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((objc_subclassing_restricted))即可</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">__attribute__((objc_subclassing_restricted))</span><br><span class="line">@interface Person : NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@interface Child: Person //Cannot subclass a class that was declared with the &apos;objc_subclassing_restricted&apos; attribute</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h1 id="objc-requires-super"><a href="#objc-requires-super" class="headerlink" title="objc_requires_super"></a>objc_requires_super</h1><p>NS_REQUIRES_SUPER 子类继承该方法时需要调用 super 否则给出编译警告<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">- (void)fatherMethod __attribute__((objc_requires_super));</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Child</span><br><span class="line">- (void)fatherMethod &#123;</span><br><span class="line"> //Method possibly missing a [super fatherMethod] call</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h1 id="objc-runtime-name"><a href="#objc-runtime-name" class="headerlink" title="objc_runtime_name"></a>objc_runtime_name</h1><p>用于 @interface 或 @protocol，将类或协议的名字在编译时指定成另一个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((objc_runtime_name(&quot;SarkGay&quot;)))</span><br><span class="line">@interface Sark : NSObject</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;, NSStringFromClass([Sark class])); // &quot;SarkGay&quot;</span><br></pre></td></tr></table></figure></p><p>所有直接使用这个类名的地方都会被替换（唯一要注意的是这时用反射就不对了），最简单粗暴的用处就是去做个类名混淆：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((objc_runtime_name(&quot;40ea43d7629d01e4b8d6289a132482d0dd5df4fa&quot;)))</span><br><span class="line">@interface SecretClass : NSObject</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>还能用数字开头，怕不怕 - -，假如写个脚本把每个类前加个随机生成的 objc_runtime_name，岂不是最最精简版的代码混淆就完成了呢…</p><p>它是我所了解的唯一一个对 objc 运行时类结构有影响的 attribute，通过编码类名可以在编译时注入一些信息，被带到运行时之后，再反解出来，这就相当于开设了一条秘密通道，打通了写码时和运行时。脑洞一下，假如把这个 attribute 定义成宏，以 annotation 的形式完成某些功能，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// @singleton 包裹了 __attribute__((objc_runtime_name(...)))</span><br><span class="line">// 将类名改名成 &quot;SINGLETON_Sark_sharedInstance&quot;</span><br><span class="line">@singleton(Sark, sharedInstance)</span><br><span class="line">@interface Sark : NSObject</span><br><span class="line">+ (instancetype)sharedInstance;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>在运行时用 <strong>attribute</strong>((constructor)) 获取入口时机，用 runtime 找到这个类，反解出 “sharedInstance” 这个 selector 信息，动态将 + alloc，- init 等方法替换，返回 + sharedInstance 单例。</p><h1 id="objc-boxable"><a href="#objc-boxable" class="headerlink" title="objc_boxable"></a>objc_boxable</h1><p>Objective-C 中的 @(…) 语法糖可以将基本数据类型 box 成 NSNumber 对象，假如想 box 一个 struct 类型或是 union 类型成 NSValue 对象，可以使用这个属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef struct __attribute__((objc_boxable)) &#123;</span><br><span class="line">CGFloat x, y, width, height;</span><br><span class="line">&#125; XXRect;</span><br></pre></td></tr></table></figure></p><p>这样一来，XXRect 就具备被 box 的能力：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CGRect rect1 = &#123;1, 2, 3, 4&#125;;</span><br><span class="line">NSValue *value1 = @(rect1); // &lt;--- Compile Error</span><br><span class="line">XXRect rect2 = &#123;1, 2, 3, 4&#125;;</span><br><span class="line">NSValue *value2 = @(rect2); // √</span><br></pre></td></tr></table></figure></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://blog.sunnyxx.com/2016/05/14/clang-attributes/" target="_blank" rel="noopener">参考地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Clang-Attribute-说明&quot;&gt;&lt;a href=&quot;#Clang-Attribute-说明&quot; class=&quot;headerlink&quot; title=&quot;Clang Attribute 说明&quot;&gt;&lt;/a&gt;Clang Attribute 说明&lt;/h1&gt;&lt;p&gt;Clang 
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>React入门</title>
    <link href="http://yoursite.com/2018/09/03/React%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2018/09/03/React入门/</id>
    <published>2018-09-03T02:50:42.000Z</published>
    <updated>2018-09-03T07:47:00.290Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>swift和OC返回指定页面</title>
    <link href="http://yoursite.com/2018/08/27/swift%E5%92%8COC%E8%BF%94%E5%9B%9E%E6%8C%87%E5%AE%9A%E9%A1%B5%E9%9D%A2/"/>
    <id>http://yoursite.com/2018/08/27/swift和OC返回指定页面/</id>
    <published>2018-08-27T08:09:05.000Z</published>
    <updated>2018-09-03T07:46:40.455Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VC-多层-push后回到指定页面的几种方法"><a href="#VC-多层-push后回到指定页面的几种方法" class="headerlink" title="VC 多层 push后回到指定页面的几种方法"></a>VC 多层 push后回到指定页面的几种方法</h1><p>写一个ViewController的类方法,核心方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func backToViewController(className: String, animated: Bool) &#123;  </span><br><span class="line">        if ((self.navigationController) != nil) &#123;  </span><br><span class="line">            let controllers: Array = (self.navigationController?.viewControllers) ?? []  </span><br><span class="line">            let res = controllers.filter &#123; (item) -&gt; Bool in  </span><br><span class="line">                guard let aClass = NSClassFromString(className) else &#123;  </span><br><span class="line">                return false  </span><br><span class="line">            &#125;  </span><br><span class="line">            return item.isKind(of: aClass)  </span><br><span class="line">        &#125;  </span><br><span class="line">        if (res.count &gt; 0) &#123;  </span><br><span class="line">            self.navigationController?.popToViewController(res[0], animated: animated)  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/heliosneverend/popToViewController.git" target="_blank" rel="noopener">示例代码Demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;VC-多层-push后回到指定页面的几种方法&quot;&gt;&lt;a href=&quot;#VC-多层-push后回到指定页面的几种方法&quot; class=&quot;headerlink&quot; title=&quot;VC 多层 push后回到指定页面的几种方法&quot;&gt;&lt;/a&gt;VC 多层 push后回到指定页面的几种
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>记录苹果设备唯一账号</title>
    <link href="http://yoursite.com/2018/08/27/%E8%AE%B0%E5%BD%95%E8%8B%B9%E6%9E%9C%E8%AE%BE%E5%A4%87%E5%94%AF%E4%B8%80%E8%B4%A6%E5%8F%B7/"/>
    <id>http://yoursite.com/2018/08/27/记录苹果设备唯一账号/</id>
    <published>2018-08-27T03:28:21.000Z</published>
    <updated>2018-09-03T07:47:22.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS获取设备唯一标识符"><a href="#iOS获取设备唯一标识符" class="headerlink" title="iOS获取设备唯一标识符"></a>iOS获取设备唯一标识符</h1><h2 id="UDID-Unique-Device-Identifier"><a href="#UDID-Unique-Device-Identifier" class="headerlink" title="UDID(Unique Device Identifier)"></a>UDID(Unique Device Identifier)</h2><p>苹果IOS设备的唯一识别码, 越狱的设备通过某些工具可以改变设备的UDID,在iOS5.0(2011年8月份)开始，苹果宣布将不再支持uniqueIdentifier方法获取设备的UDID，iOS5以下是可以用的, 在 2013年3月21日苹果已经通知开发者,从2013年5月1日起，访问UIDIDs的程序将不再被审核通过替代的方案是开发者应该使用“在iOS 6中介绍的Vendor或Advertising标示符</p><hr><h2 id="UUID-Universally-Unique-Identifier"><a href="#UUID-Universally-Unique-Identifier" class="headerlink" title="UUID(Universally Unique Identifier)"></a>UUID(Universally Unique Identifier)</h2><p>唯一识别码<em>它是让分布式系统中的所有元素</em>都能有唯一的辨识资讯<em>而不需要透过中央控制端来做辨识资讯的指定</em>苹果公司建议使用UUID为应用生成唯一标识字符串](/uploads/a16006ef33534d3c6a28263d112ebed7/唯一识别码<em>它是让分布式系统中的所有元素</em>都能有唯一的辨识资讯<em>而不需要透过中央控制端来做辨识资讯的指定</em>苹果公司建议使用UUID为应用生成唯一标识字符串</p><hr><h2 id="MAC-Address-Medium-Access-Control"><a href="#MAC-Address-Medium-Access-Control" class="headerlink" title="MAC Address(Medium Access Control)"></a>MAC Address(Medium Access Control)</h2><p>媒体访问控制，或称为物理地址、硬件地址，用来定义网络设备的位置。在OSI模型中，第三层网络层负责 IP地址，第二层数据链路层则负责 MAC地址。因此一个主机会有一个MAC地址，而每个网络位置会有一个专属于它的IP地址。MAC地址是网卡决定的，是固定的</p><hr><h2 id="OPEN-UDID"><a href="#OPEN-UDID" class="headerlink" title="OPEN UDID"></a>OPEN UDID</h2><p>OpenUDID是通过第一个带有OpenUDID SDK包的App生成，如果你完全删除全部带有OpenUDID SDK包的App（比如恢复系统等），那么OpenUDID会重新生成，而且和之前的值会不同，相当于新设备； 优点是没有用到MAC地址；不同设备能够获取各自唯一的识别码，保证了唯一性，可以用于以往UDID的相关用途；从代码分析OpenUDID的获取，识别码获取方便并且保存谨慎。缺点是当将设备上所有使用了OpenUDID方案的应用程序删除，且设备关机重启，xcode彻底清除并重启，重装应用程序去获取OpenUDID，此时OpenUDID变化，与之前不一样了，所有OpenUDID应用卸载后，由UIPasteboard保存的数据即被清除，重装故会重新获取新的OpenUDID。 那么当因为用户干预或者恶意程序，致使UIPasteboard数据清除，从而导致OpenUDID被删除，重装也会获取新的OpenUDID。</p><hr><h2 id="广告标识符-IDFA-identifierForldentifier"><a href="#广告标识符-IDFA-identifierForldentifier" class="headerlink" title="广告标识符(IDFA-identifierForldentifier)"></a>广告标识符(IDFA-identifierForldentifier)</h2><p>是iOS 6中另外一个新的方法，提供了一个方法advertisingIdentifier，通过调用该方法会返回一个NSUUID实例，最后可以获得一个UUID，由系统存储着的。不过即使这是由系统存储的，但是有几种情况下，会重新生成广告标示符。如果用户完全重置系统（(设置程序 -&gt; 通用 -&gt; 还原 -&gt; 还原位置与隐私) ，这个广告标示符会重新生成。另外如果用户明确的还原广告(设置程序-&gt; 通用 -&gt; 关于本机 -&gt; 广告 -&gt; 还原广告标示符) ，那么广告标示符也会重新生成。关于广告标示符的还原，有一点需要注意：如果程序在后台运行，此时用户“还原广告标示符”，然后再回到程序中，此时获取广 告标示符并不会立即获得还原后的标示符。必须要终止程序，然后再重新启动程序，才能获得还原后的广告标示符。</p><hr><h2 id="Vendor标识符-IDFV-identifierForVendor"><a href="#Vendor标识符-IDFV-identifierForVendor" class="headerlink" title="Vendor标识符(IDFV-identifierForVendor)"></a>Vendor标识符(IDFV-identifierForVendor)</h2><p>Vendor是CFBundleIdentifier（反转DNS格式）的前两部分。来自同一个运营商的应用运行在同一个设备上，此属性的值是相同的；不同的运营商应用运行在同一个设备上值不同。 经测试，只要设备上有一个运营商的app，重新安装后的identifierForVendor值不变，如果该运营商的app全部删除，重新安装后的identifierForVendor值改变。</p><hr><h2 id="调研结果"><a href="#调研结果" class="headerlink" title="调研结果"></a>调研结果</h2><p>IMEI 苹果允许的API 但不能获取,不会变化,设备唯一。</p><hr><p>UDID 曾经可以获取,单现在也成为禁止调用的API,不会变化,设备唯一。</p><hr><p>MAC 不能直接通过设备API获取,某种脑洞可以通过WIFI下路由器反馈信息来回传MAC地址,很不方便不会变化,设备唯一</p><hr><p>IDFA 广告标示符,经常容易变,每当用户针对应用程序关闭再开启一次广告追踪就会发生变化</p><hr><p>IDFV 厂商标示符,不太容易变,每当用户卸载完应用厂家旗下所有的应用程序后,再次安装,会发生变化</p><hr><p>NSUUID 苹果API接口,每次获取都变化</p><hr><p>可以确认的是，在众多可选的标识方案里，都不能保证永远不变，所以必须配合钥匙扣使用，有了钥匙扣至少保证，只要用户不刷机，无论是升级系统，还是卸载光所有的应用程序，都不会发生变化,只要有了钥匙扣的辅助，可以说随便选一个标识，只要存入钥匙圈，都能保证不变了。推荐选择了目前来看更加稳定的IDFV</p><p><a href="https://github.com/heliosneverend/HeliosKeychain" target="_blank" rel="noopener">示例代码Demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;iOS获取设备唯一标识符&quot;&gt;&lt;a href=&quot;#iOS获取设备唯一标识符&quot; class=&quot;headerlink&quot; title=&quot;iOS获取设备唯一标识符&quot;&gt;&lt;/a&gt;iOS获取设备唯一标识符&lt;/h1&gt;&lt;h2 id=&quot;UDID-Unique-Device-Identi
      
    
    </summary>
    
      <category term="拾遗" scheme="http://yoursite.com/categories/%E6%8B%BE%E9%81%97/"/>
    
    
      <category term="拾遗" scheme="http://yoursite.com/tags/%E6%8B%BE%E9%81%97/"/>
    
  </entry>
  
  <entry>
    <title>前端基础</title>
    <link href="http://yoursite.com/2018/04/02/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/04/02/前端基础/</id>
    <published>2018-04-02T04:26:59.000Z</published>
    <updated>2018-09-03T09:39:34.590Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Python基础</title>
    <link href="http://yoursite.com/2018/02/27/Python%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/02/27/Python基础/</id>
    <published>2018-02-27T00:11:25.000Z</published>
    <updated>2018-09-03T09:38:06.508Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Shell多终端间发送消息</title>
    <link href="http://yoursite.com/2017/08/31/Shell%E5%A4%9A%E7%BB%88%E7%AB%AF%E9%97%B4%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF/"/>
    <id>http://yoursite.com/2017/08/31/Shell多终端间发送消息/</id>
    <published>2017-08-31T05:32:23.000Z</published>
    <updated>2018-09-03T10:43:27.852Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用who命令查看当前有几个终端启动"><a href="#使用who命令查看当前有几个终端启动" class="headerlink" title="使用who命令查看当前有几个终端启动"></a>使用who命令查看当前有几个终端启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//参数1：用户名 参数2：用户所在终端 参数3：用户登录时间</span><br><span class="line">bogon:~ YZY$ who</span><br><span class="line">YZY      console  Jul 21 23:13 </span><br><span class="line">YZY      ttys004  Jul 23 14:07</span><br></pre></td></tr></table></figure><h3 id="启动发送消息功能"><a href="#启动发送消息功能" class="headerlink" title="启动发送消息功能"></a>启动发送消息功能</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bogon:~ YZY$ mesg</span><br></pre></td></tr></table></figure><p>输出is y表示启动了发送消息功能，否则表示没有开启。</p><h3 id="使用who命令查看当前有几个终端启动-1"><a href="#使用who命令查看当前有几个终端启动-1" class="headerlink" title="使用who命令查看当前有几个终端启动"></a>使用who命令查看当前有几个终端启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bogon:~ YZY$ who -T</span><br></pre></td></tr></table></figure><p>-表示没有启动发送消息功能，+表示开通了</p><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息:"></a>发送消息:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write YZY ttys004</span><br></pre></td></tr></table></figure><h3 id="开启消息功能"><a href="#开启消息功能" class="headerlink" title="开启消息功能"></a>开启消息功能</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mseg y</span><br></pre></td></tr></table></figure><h3 id="退出发送消息"><a href="#退出发送消息" class="headerlink" title="退出发送消息"></a>退出发送消息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crtl c</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;使用who命令查看当前有几个终端启动&quot;&gt;&lt;a href=&quot;#使用who命令查看当前有几个终端启动&quot; class=&quot;headerlink&quot; title=&quot;使用who命令查看当前有几个终端启动&quot;&gt;&lt;/a&gt;使用who命令查看当前有几个终端启动&lt;/h3&gt;&lt;figure c
      
    
    </summary>
    
      <category term="Shell" scheme="http://yoursite.com/categories/Shell/"/>
    
    
      <category term="Shell" scheme="http://yoursite.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Shell中的数据库操作</title>
    <link href="http://yoursite.com/2017/08/26/Shell%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2017/08/26/Shell中的数据库操作/</id>
    <published>2017-08-26T02:32:23.000Z</published>
    <updated>2018-09-03T10:41:36.407Z</updated>
    
    <content type="html"><![CDATA[<h3 id="打开数据库"><a href="#打开数据库" class="headerlink" title="打开数据库"></a>打开数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#脚本中书写：</span><br><span class="line">MYSQL=$(which mysql)</span><br><span class="line">$MYSQL -u root -p</span><br></pre></td></tr></table></figure><h3 id="退出数据库"><a href="#退出数据库" class="headerlink" title="退出数据库"></a>退出数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#登录数据库：</span><br><span class="line">MYSQL=$(which mysql)</span><br><span class="line">#$MYSQL -u root -p 表示登录数据库，后面[-e &apos;exit&apos;]命令表示登录后立即执行退出指令</span><br><span class="line">$MYSQL -u root -p -e &apos;exit&apos;</span><br></pre></td></tr></table></figure><h3 id="显示数据库列表"><a href="#显示数据库列表" class="headerlink" title="显示数据库列表"></a>显示数据库列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MYSQL=$(which mysql)</span><br><span class="line">$MYSQL -u root -p -e &apos;show databases&apos;</span><br></pre></td></tr></table></figure><h3 id="查询数据库表"><a href="#查询数据库表" class="headerlink" title="查询数据库表"></a>查询数据库表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MYSQL=$(which mysql)</span><br><span class="line">$MYSQL db_123 -u root -p -e &apos;select * from t_student&apos;</span><br><span class="line">#格式 $MYSQL 数据库名  -u root -p -e 查询命令</span><br></pre></td></tr></table></figure><h3 id="查询数据库表-amp-输入重定向"><a href="#查询数据库表-amp-输入重定向" class="headerlink" title="查询数据库表&amp;输入重定向"></a>查询数据库表&amp;输入重定向</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MYSQL=$(which mysql)</span><br><span class="line">$MYSQL db_123 -u root -p &lt;&lt; MARK</span><br><span class="line">select * from t_student</span><br><span class="line">MARK</span><br><span class="line"></span><br><span class="line"># 开始标记和结束标记语法：&lt;T&gt; 代码 &lt;T&gt;</span><br></pre></td></tr></table></figure><h3 id="插入表数据"><a href="#插入表数据" class="headerlink" title="插入表数据"></a>插入表数据</h3><h4 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$MYSQL db_123 -u root -p &lt;&lt;MARK</span><br><span class="line">insert into t_student values(3,&quot;Mike&quot;,1)</span><br><span class="line">MARK</span><br></pre></td></tr></table></figure><h4 id="案例二-动态传递参数，并且返回执行状态"><a href="#案例二-动态传递参数，并且返回执行状态" class="headerlink" title="案例二 动态传递参数，并且返回执行状态"></a>案例二 动态传递参数，并且返回执行状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MYSQL=$&#123;which mysql&#125;</span><br><span class="line">#若不等于某个长度</span><br><span class="line">if [$# -ne 3]</span><br><span class="line">then</span><br><span class="line">echo &quot;传递的参数不对&quot;</span><br><span class="line">else </span><br><span class="line">#插入数据</span><br><span class="line">$MYQSL db_123 -u root -p &lt;&lt; MARK</span><br><span class="line">insert into t_student values(4,&apos;Grap&apos;,1)</span><br><span class="line">MARK</span><br><span class="line">#执行状态</span><br><span class="line">if []</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;打开数据库&quot;&gt;&lt;a href=&quot;#打开数据库&quot; class=&quot;headerlink&quot; title=&quot;打开数据库&quot;&gt;&lt;/a&gt;打开数据库&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;
      
    
    </summary>
    
      <category term="Shell" scheme="http://yoursite.com/categories/Shell/"/>
    
    
      <category term="Shell" scheme="http://yoursite.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Shell重定向</title>
    <link href="http://yoursite.com/2017/08/25/Shell%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <id>http://yoursite.com/2017/08/25/Shell重定向/</id>
    <published>2017-08-25T10:32:23.000Z</published>
    <updated>2018-09-03T10:35:42.433Z</updated>
    
    <content type="html"><![CDATA[<h3 id="shell中将输入、输出和错误用三种描述符表示："><a href="#shell中将输入、输出和错误用三种描述符表示：" class="headerlink" title="shell中将输入、输出和错误用三种描述符表示："></a>shell中将输入、输出和错误用三种描述符表示：</h3><p>标准输入STDIN，用0表示，接受键盘输入<br>使用cat命令接受键盘输入<br>非标准输入-文件输入，即使用cat读取文件<br>标准输出STDOUT，对应终端显示，1表示<br>标准错误STDERR，2表示</p><h3 id="Demo1：重定向输出到文件中"><a href="#Demo1：重定向输出到文件中" class="headerlink" title="Demo1：重定向输出到文件中"></a>Demo1：重定向输出到文件中</h3><p>ls -l显示文件的信息</p><blockquote><blockquote><p>追加内容<br>替换内容<br>who命令打印当前登录的系统用户信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls -l hello.sh</span><br><span class="line">cat hello.sh</span><br><span class="line">#追加内容</span><br><span class="line">who&gt;&gt;hello.sh</span><br><span class="line">cat hello.sh</span><br></pre></td></tr></table></figure></p></blockquote></blockquote><h3 id="Demo2：重定向错误信息输出到文件中"><a href="#Demo2：重定向错误信息输出到文件中" class="headerlink" title="Demo2：重定向错误信息输出到文件中"></a>Demo2：重定向错误信息输出到文件中</h3><p>-al查找文件<br>❌错误做法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al hello.sh &gt; aim.sh</span><br></pre></td></tr></table></figure></p><p>上面执行后，如果没有aim.sh文件，则会自动创建aim.sh文件，但是最终都不会将错误信息输出到目标文件aim.sh中<br>所以如果我们需要保存错误信息，就需要采用STDERR实现<br>✅正确做法：<br>将STDERR文件描述修改为2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al a.sh 2&gt;hello.sh</span><br></pre></td></tr></table></figure></p><h3 id="Demo3：同时保存错误和数据到不同文件"><a href="#Demo3：同时保存错误和数据到不同文件" class="headerlink" title="Demo3：同时保存错误和数据到不同文件"></a>Demo3：同时保存错误和数据到不同文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#将错误数据重定向到error.sh文件中,将查找结果保存到hello.sh文件中</span><br><span class="line">ls -al a.sh b.sh c.sh 2&gt;error.sh &gt;hello.sh</span><br></pre></td></tr></table></figure><h3 id="Demo4：同时保存错误和数据到同一个文件"><a href="#Demo4：同时保存错误和数据到同一个文件" class="headerlink" title="Demo4：同时保存错误和数据到同一个文件"></a>Demo4：同时保存错误和数据到同一个文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls -a file.sh &amp;&gt;result.sh</span><br><span class="line">#查看文件内容</span><br><span class="line">cat result.sh</span><br></pre></td></tr></table></figure><h2 id="临时重定向输出"><a href="#临时重定向输出" class="headerlink" title="临时重定向输出:"></a>临时重定向输出:</h2><p>&amp;命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#将输出信息作为错位日志</span><br><span class="line">echo &quot;haha&quot; &gt;&amp; 2</span><br></pre></td></tr></table></figure></p><p>执行：将STDERR信息重定向到error.sh文件中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./hello.sh 2&gt;error.sh</span><br></pre></td></tr></table></figure></p><h2 id="永久重定向输出"><a href="#永久重定向输出" class="headerlink" title="永久重定向输出"></a>永久重定向输出</h2><p>exec命令<br>保存数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#在文件内部</span><br><span class="line">exec 1 &gt; new.sh</span><br><span class="line">echo &quot;haha&quot;</span><br></pre></td></tr></table></figure></p><h2 id="重定向输入"><a href="#重定向输入" class="headerlink" title="重定向输入:"></a>重定向输入:</h2><p>命令符&lt;<br>一旦设置了输入重定向指令，则read指令会自动连接输入的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#从hello.sh文件中读取数据</span><br><span class="line">exec 0&lt; hello.sh</span><br><span class="line">count=0</span><br><span class="line">while read line</span><br><span class="line">do</span><br><span class="line">echo &quot;当前行的内容数据是：$line，当前行数：$count&quot;</span><br><span class="line">count=$[$count + 1]</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><h2 id="自定义重定向输出"><a href="#自定义重定向输出" class="headerlink" title="自定义重定向输出:"></a>自定义重定向输出:</h2><p>使用exec命令<br>🎈下面这种方式，会替换掉要定向文件里面的所有内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exec 3&gt; hello.sh</span><br><span class="line">#临时重定向，标记文件</span><br><span class="line">echo &quot;haha&quot; &gt;&amp;3</span><br></pre></td></tr></table></figure></p><p>🎈如果在要定向的文件中追加内容，而不是替换：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exec 3 &gt;&gt; hello.sh</span><br><span class="line">#临时重定向，标记文件</span><br><span class="line">echo &quot;haha&quot; &gt;&amp;3</span><br></pre></td></tr></table></figure></p><h2 id="重定向输出恢复"><a href="#重定向输出恢复" class="headerlink" title="重定向输出恢复"></a>重定向输出恢复</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#将3重定向为1</span><br><span class="line">exec 3 &gt;&amp; 1</span><br><span class="line">exec 1&gt; hello.sh</span><br><span class="line">echo &quot;haha&quot;</span><br><span class="line">#将1恢复到3</span><br><span class="line">exec 1 &gt;&amp; 3</span><br><span class="line">echo &quot;xixi&quot;</span><br></pre></td></tr></table></figure><h2 id="创建读写文件描述符"><a href="#创建读写文件描述符" class="headerlink" title="创建读写文件描述符"></a>创建读写文件描述符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">exec 3&lt;&gt;hello.sh</span><br><span class="line">#从hello文件中读取内容</span><br><span class="line">read line &gt;&amp;3</span><br><span class="line">echo &quot;$line&quot;</span><br><span class="line">#写入内容</span><br><span class="line">echo &quot;hah&quot; &gt;&amp; 3</span><br><span class="line">#注意：此写入会替换掉从第二行开始的所有内容</span><br><span class="line">#因为上面读取完第一行后，此时文件指针指向到了第二行</span><br></pre></td></tr></table></figure><h2 id="关闭读写文件描述符"><a href="#关闭读写文件描述符" class="headerlink" title="关闭读写文件描述符"></a>关闭读写文件描述符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec 3 &gt;&amp;-</span><br></pre></td></tr></table></figure><h2 id="阻止命令输出"><a href="#阻止命令输出" class="headerlink" title="阻止命令输出:"></a>阻止命令输出:</h2><p>输出到系统一个临时文件中，但是此临时文件不会保存内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al &gt; /dev/null</span><br></pre></td></tr></table></figure></p><p>使用阻止输出来清空文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /dev/null &gt; hello.sh</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;shell中将输入、输出和错误用三种描述符表示：&quot;&gt;&lt;a href=&quot;#shell中将输入、输出和错误用三种描述符表示：&quot; class=&quot;headerlink&quot; title=&quot;shell中将输入、输出和错误用三种描述符表示：&quot;&gt;&lt;/a&gt;shell中将输入、输出和错
      
    
    </summary>
    
      <category term="Shell" scheme="http://yoursite.com/categories/Shell/"/>
    
    
      <category term="Shell" scheme="http://yoursite.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>mysql数据库操作</title>
    <link href="http://yoursite.com/2017/08/23/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2017/08/23/mysql数据库操作/</id>
    <published>2017-08-23T02:12:23.000Z</published>
    <updated>2018-09-03T10:38:41.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL操作命令："><a href="#MySQL操作命令：" class="headerlink" title="MySQL操作命令："></a>MySQL操作命令：</h2><h3 id="连接-登录-数据库："><a href="#连接-登录-数据库：" class="headerlink" title="连接(登录)数据库："></a>连接(登录)数据库：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u 用户名 -p</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br><span class="line">//然后输入密码</span><br></pre></td></tr></table></figure><h3 id="退出数据库："><a href="#退出数据库：" class="headerlink" title="退出数据库："></a>退出数据库：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; exit</span><br></pre></td></tr></table></figure><h3 id="显示所有的数据库"><a href="#显示所有的数据库" class="headerlink" title="显示所有的数据库"></a>显示所有的数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show databases</span><br></pre></td></tr></table></figure><h3 id="进入数据库"><a href="#进入数据库" class="headerlink" title="进入数据库"></a>进入数据库</h3><p>mysql&gt; use 库名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`mysql&gt; use db_test`</span><br></pre></td></tr></table></figure></p><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; drop database 库名</span><br></pre></td></tr></table></figure><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create database 库名</span><br></pre></td></tr></table></figure><h3 id="创建数据库表"><a href="#创建数据库表" class="headerlink" title="创建数据库表"></a>创建数据库表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table 表名</span><br><span class="line">mysql&gt; create table t_studentList(s_id int(4) not null primary key,s_name char(20),sex int(4) not null default &apos;0&apos;)</span><br><span class="line">创建一个学生表</span><br><span class="line">//s_id是int类型，四个字符长度，不可为空，</span><br><span class="line">//s_name是char类型，20个字符长度</span><br><span class="line">//sex是int类型4个长度，不可为空,默认是0</span><br></pre></td></tr></table></figure><h3 id="显示数据库表"><a href="#显示数据库表" class="headerlink" title="显示数据库表"></a>显示数据库表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show tables</span><br></pre></td></tr></table></figure><h3 id="插入表数据"><a href="#插入表数据" class="headerlink" title="插入表数据"></a>插入表数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在t_student表中</span><br><span class="line">mysql&gt; insert into t_student values(0,&quot;Bill&quot;,0)</span><br></pre></td></tr></table></figure><h3 id="查询表数据"><a href="#查询表数据" class="headerlink" title="查询表数据"></a>查询表数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t_student</span><br></pre></td></tr></table></figure><h3 id="按条件查询"><a href="#按条件查询" class="headerlink" title="按条件查询"></a>按条件查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t_student where s_id = 2</span><br></pre></td></tr></table></figure><h3 id="更新表数据"><a href="#更新表数据" class="headerlink" title="更新表数据"></a>更新表数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update t_student set s_sex=1 where s_name=&apos;Bill&apos;</span><br></pre></td></tr></table></figure><h3 id="删除表数据"><a href="#删除表数据" class="headerlink" title="删除表数据"></a>删除表数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; delete from t_student where s_name = &quot;Bill&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MySQL操作命令：&quot;&gt;&lt;a href=&quot;#MySQL操作命令：&quot; class=&quot;headerlink&quot; title=&quot;MySQL操作命令：&quot;&gt;&lt;/a&gt;MySQL操作命令：&lt;/h2&gt;&lt;h3 id=&quot;连接-登录-数据库：&quot;&gt;&lt;a href=&quot;#连接-登录-数据库：&quot;
      
    
    </summary>
    
      <category term="Shell" scheme="http://yoursite.com/categories/Shell/"/>
    
    
      <category term="Shell" scheme="http://yoursite.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Shell函数和管道以及bash计算器</title>
    <link href="http://yoursite.com/2017/08/21/Shell%E5%87%BD%E6%95%B0%E5%92%8C%E7%AE%A1%E9%81%93%E4%BB%A5%E5%8F%8Abash%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
    <id>http://yoursite.com/2017/08/21/Shell函数和管道以及bash计算器/</id>
    <published>2017-08-21T01:12:23.000Z</published>
    <updated>2018-09-03T10:29:51.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>使用function关键字来定义函数<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function 函数名()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>带参数的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function add()&#123;</span><br><span class="line">    echo &quot;第一个参数 文件名字：$0&quot;</span><br><span class="line">    echo &quot;第二个参数: $1&quot;</span><br><span class="line">    echo &quot;第三个参数: $2&quot;</span><br><span class="line">    return &quot;haha&quot;</span><br><span class="line">&#125;</span><br><span class="line">#调用方法,传参</span><br><span class="line">add $0 100</span><br></pre></td></tr></table></figure></p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>一个命令的输出作为下一个命令的输入，此时需要用到管道<br>语法结构：command1 | command2</p><h2 id="bash计算器"><a href="#bash计算器" class="headerlink" title="bash计算器"></a>bash计算器</h2><p>⚠️bash计算器，实际是一种编程语言，它允许使用命令行输入浮点数及表达式，然后解释并执行表达式，并返回结果。<br>⚠️在shell脚步语言中使用命令bc，可以打开并访问bash计算器<br>⚠️退出计算器：输入quit命令并回车</p><p>将bash计算器应用到shell中：<br>语法结构：val=$(echo “options;expression” | bc)<br>解释：options表示选项，expression表示表达式</p><h3 id="应用1"><a href="#应用1" class="headerlink" title="应用1"></a>应用1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val=$(echo &quot;1.56 * 100&quot; | bc)</span><br><span class="line">echo $val</span><br><span class="line">#结果是156.00</span><br></pre></td></tr></table></figure><h3 id="应用2"><a href="#应用2" class="headerlink" title="应用2"></a>应用2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#FLAG为开始、结束标记，可以使用任意字符</span><br><span class="line">val=$(bc&lt;&lt;FLAG</span><br><span class="line">options</span><br><span class="line">expression</span><br><span class="line">FLAG</span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val=$(bc&lt;&lt;A</span><br><span class="line">a=($val1 * $val2)</span><br><span class="line">b=($a - 10)</span><br><span class="line">A</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h2&gt;&lt;p&gt;使用function关键字来定义函数&lt;br&gt;语法：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;t
      
    
    </summary>
    
      <category term="Shell" scheme="http://yoursite.com/categories/Shell/"/>
    
    
      <category term="Shell" scheme="http://yoursite.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Shell文件操作相关</title>
    <link href="http://yoursite.com/2017/08/20/Shell%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3/"/>
    <id>http://yoursite.com/2017/08/20/Shell文件操作相关/</id>
    <published>2017-08-20T04:01:23.000Z</published>
    <updated>2018-09-03T10:27:18.674Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p>文件a： a.sh<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!#/bin/bash</span><br><span class="line">echo &quot;a&quot;</span><br></pre></td></tr></table></figure></p><p>文件b： b.sh<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">!#/bin/bash</span><br><span class="line">./a.sh</span><br><span class="line">echo &quot;b</span><br></pre></td></tr></table></figure></p><p>此时文件b包含了文件a，执行b文件，就会把文件a和文件b的内容都执行</p><h3 id="方式二-使用关键字source"><a href="#方式二-使用关键字source" class="headerlink" title="方式二 使用关键字source"></a>方式二 使用关键字source</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">!#/bin/bash</span><br><span class="line">source ./a.sh</span><br><span class="line">echo &quot;b</span><br></pre></td></tr></table></figure><h2 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h2><p>作用：<br>查看文件内容<br>连接文件<br>创建一个或多个文件<br>重定向输出到终端<br>重定向到文件<br>查看文件内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat hello.sh</span><br></pre></td></tr></table></figure></p><p>显示文件内容和行号:<br>使用-n<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n hello.sh</span><br></pre></td></tr></table></figure></p><p>显示文件内容和行号,只标记空白行:<br>使用-b<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -b a.sh</span><br></pre></td></tr></table></figure></p><p>⚠️多行内容转为单行：<br>使用-e，会在每一行内容的最后加入$符号</p><p>⚠️接受标准输入，输出标准输出：<br>输入后使用回车键<br>使用ctrl+c退出</p><h2 id="读取输入内容"><a href="#读取输入内容" class="headerlink" title="读取输入内容"></a>读取输入内容</h2><p>使用关键字read<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;请输入名字&quot;</span><br><span class="line">read name</span><br><span class="line">echo &quot;您输入的名字是:$name&quot;</span><br></pre></td></tr></table></figure></p><p>另一种写法: 使用-p<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read -p &quot;请输入您的名字&quot; name</span><br><span class="line">echo &quot;您输入的名字是:$name&quot;</span><br></pre></td></tr></table></figure></p><p>带有超时读取：使用-t<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if read -t 6 -p &quot;请输入您的名字:&quot; name</span><br><span class="line">then </span><br><span class="line">echo &quot;您输入的名字是:$name&quot;</span><br><span class="line">else </span><br><span class="line">echo &quot;超时&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><p>隐藏输入内容，密码，使用-s<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if read -s -p &quot;请输入您的密码:&quot; pwd</span><br></pre></td></tr></table></figure></p><p>从文件中按行读取内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat file.sh | while read line</span><br><span class="line">do </span><br><span class="line">echo &quot;每一行的内容是：$&#123;line&#125;&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><h2 id="printf命令详解"><a href="#printf命令详解" class="headerlink" title="printf命令详解"></a>printf命令详解</h2><p>printf区别于echo命令，不会换行，一般用于格式化打印输出<br>语法：printf fomat -string 参数列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#打印表头</span><br><span class="line">printf &quot;%-10s %-8s %-4s \n&quot; 姓名 性别 体重kg</span><br><span class="line">#打印内容</span><br><span class="line">printf &quot;%-10s %-8s %-4s \n&quot; Mike 女 62kg</span><br><span class="line">printf &quot;%-10s %-8s %-4s \n&quot; Bill 男 50kg</span><br></pre></td></tr></table></figure></p><p>解释：%-10s表示宽度为10个字符的距离,-表示左对齐</p><h2 id="创建临时文件"><a href="#创建临时文件" class="headerlink" title="创建临时文件"></a>创建临时文件</h2><p>使用命令符mktemp<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mktemp hello.sh</span><br><span class="line">#创建一个以haha为前缀，以随机6位字母为结尾文件名的文件</span><br><span class="line">mktemp haha.XXXXXX</span><br></pre></td></tr></table></figure></p><p>在脚本中创建：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#创建临时文件</span><br><span class="line">tempfile=$(mktemp newfile.XXXXXX)</span><br><span class="line">#重定向临时文件</span><br><span class="line">exec 3&gt; $tempfile</span><br><span class="line">echo &quot;$tempfile&quot;</span><br><span class="line">#输出内容到重定向的文件中</span><br><span class="line">echo &quot;哈哈&quot; &gt;&amp;3</span><br><span class="line">#关闭重定向</span><br><span class="line">exec 3&gt;&amp;-</span><br><span class="line">#打印文件内容</span><br><span class="line">cat $tempfile</span><br><span class="line">#删除文件</span><br><span class="line">rm -f $tempfile 2&gt; /dev/null</span><br></pre></td></tr></table></figure></p><h2 id="在系统临时目录创建临时文件"><a href="#在系统临时目录创建临时文件" class="headerlink" title="在系统临时目录创建临时文件"></a>在系统临时目录创建临时文件</h2><p>使用命令符-t创建：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mktemp -t newfile.XXXXXX</span><br></pre></td></tr></table></figure></p><h2 id="创建临时目录"><a href="#创建临时目录" class="headerlink" title="创建临时目录"></a>创建临时目录</h2><p>使用命令符-d创建<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tempfile=$(mktemp -d newfile.XXXXXX)</span><br><span class="line">#进入临时目录</span><br><span class="line">cd $tempfile</span><br><span class="line">$在临时目录创建临时文件</span><br><span class="line">tempfile1=$(mktemp newfile.XXXXXX)</span><br><span class="line">#自定义文件描述符 重定向输出</span><br><span class="line">exec 7 &gt; $tempfile1</span><br><span class="line">exec &quot;哈哈&quot; &gt;&amp; 7</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;文件包含&quot;&gt;&lt;a href=&quot;#文件包含&quot; class=&quot;headerlink&quot; title=&quot;文件包含&quot;&gt;&lt;/a&gt;文件包含&lt;/h2&gt;&lt;h3 id=&quot;方式一&quot;&gt;&lt;a href=&quot;#方式一&quot; class=&quot;headerlink&quot; title=&quot;方式一&quot;&gt;&lt;/a&gt;方式
      
    
    </summary>
    
      <category term="Shell" scheme="http://yoursite.com/categories/Shell/"/>
    
    
      <category term="Shell" scheme="http://yoursite.com/tags/Shell/"/>
    
  </entry>
  
</feed>
